# 專案 1 示範

Hacker News AI Podcast NextJS Monorepo

## 完整敏捷工作流程

## **關於想要使用 facades 來包裝事物提供了過多的細節，這確實導致 AI 在我沒有注意到之前就搞砸了一些事情，讓它進行了大量的 story 更新——教訓是，不要在技術偏好中放入太多內容，因為 llm 會在更新 epics 和 stories 時過度使用它，如果沒有注意到，稍後清理起來會很麻煩。**

**這種胡鬧的結果在隨意產生的 stories 中顯而易見。**

# 示範資訊

- 0-brief.md 是透過與 Analyst 討論一個想法而產生的。(Gemini 2.5 Pro)
- brief 的結尾有用於啟動 PM 進入 PRD 建立模式的交接提示。
- 1-prd.md 是從互動模式中一次很棒的討論產生的。prd 中有一些不應出現在發行版本中的引用雜訊。
- prd 的結尾有檢查清單的輸出以及給 architect 的提示。
- 在運行 architect 之前，我還在 ui-ux-spec 模式下運行了 design-architect 來產生該文件，該文件為前端應用程式部分提供了一些更側重於 UI 的 PRD 級別細節。
- 然後我針對 architect 運行了 PM 提示——這些提示傳遞的好處是它們攜帶了在對話中討論的額外細節，而這些細節不屬於該文件。因此，例如，當我與 PM 交談，高層次地審查 stories 和 epics 時——我會隨機想到很多較低層次的細節——順序問題——技術選擇——所以我可能會讓 PM 知道——他會記錄下來，如果它們不屬於 PRD，它們就會進入提示。
- 哦——V3 PM 還有一個很酷的功能——除了 YOLO 或不 YOLO——它還有兩種不同的風格來產生高層次的 epics 和 stories——我認為它們應該是高層次的業務成果導向——但也有一個模式，假設會跳過 architect，它會在 story AC 中加入更多技術細節。我不喜歡那種模式——V2 有點像那樣運作，對我個人口味來說，在那個層級上做得太多了——但現在這是一個選擇！
- 我還創建了一個 0-technical-preferences.md 文件——這是一個 V3 的新功能，在我看來是個遊戲規則改變者。當你建構應用程式時，你可以追蹤你偏好的架構設計以及編碼模式和實踐。如果它們在該文件中，並且對於正在討論的專案有意義，architect 可以在適當的地方包含它們或建議它們。因此，例如，我想要一個六邊形架構，我就不必每次都解釋它。
- 我以一種不清楚的方式提到了太多關於 facade 的內容，而 architect 在整個檢查清單運行完畢並且我們檢查了所有部分之後，給了我一份建議變更的輸出——我應該更仔細地閱讀它，但當時急於產生示範內容——所以當我讓 PO 將所有改進應用到所有 stories 時，有幾個我不得不修正，它有點 facade 瘋狂了。
- 但我有點操之過急了——architect 是在一個非常有幫助的互動模式下完成的——引導我完成了範本的每個部分！
- 然後我以產生前端架構模式運行了 design architect——它產生了一個完整詳細的前端架構——我不確定對於這個只有兩個簡單畫面的簡單專案 UI 來說是否矯枉過正，但我想測試一下。我需要與前端專家進行更多諮詢，因為我現在更像是一名後端工程師——但我認為它產生了一份有用的文件。
- 最棒的部分是它還為我產生了一個 V0 提示——它接收了 PRD、Architecture、ui-ux-spec 和前端架構，並精心製作了一個詳細的提示——比我臨時手動編寫的要好得多。
  我將完整的提示放入 V0——然後我得到了我設想的完整功能的 UI 實際運作——準備好用真實的資料來源取代模式資料——令人難以置信！——提示在檔案 9-v0-one-shot-prompt.txt 中——試試看！那是在沒有任何調整的情況下。
- 然後我讓 PO 採納了 arch 建議的變更和前端建議的變更——然後 PO 在與我確認所有變更後，給了我一份完整的 PRD 更新版本（所有 epics 和 stories 都在一次性輸出中修正了）——我本應該修正一些，但當時很匆忙，只是告訴他 YOLO 所有變更，哈哈。
- 我想讓 PO 在一個新的實例中使用所有更新的文件進行完整的、大規模的檢查清單運行，以找出任何問題——這可以在 7-po-checklist-result.md 檔案中看到。

順帶一提——原始的 PRD 在檔案 1-prd 中——而 8-prd-po-updated 是包含了其他建議以及檢查清單運行中一些變更的版本。

- 一旦所有這些都在 cursor 中——我接著使用了新的 doc-sharding-task.md（它由一個 doc-sharding-template 提供支援，因此很容易修改）——它採用了最終的架構、最終的 PRD 和最終的前端架構——然後它在資料夾 10-sharded-docs 中輸出了所有較小的細粒度檔案。共享是透過一個普通的 agent（沒有規則或模式自訂）完成的——這是 task 檔案的好處——不需要讓這些不常用的 task 佔用自訂 agent 的位置。

- dev agent 和 SM 在使用這些較小文件方面保持一致，並且已經進行了調整以產生 stories。資料夾 11 包含了一些已建立的細粒度 stories 的範例——只是為了好玩，我讓 gemini2.5 pro web 中的 POSM YOLO 了前幾個 epics 的所有詳細 stories。我不建議在現實中這樣做——如果事情發生變化或轉向或其他情況，你會失去一個 story 的 dev notes 的好處，這些筆記會在下一個 story 建立之前立即提供資訊。但是這樣做很有趣，可以看到模型產生 stories 的情況，以及對於給定模型，story 的詳細程度是否已調整好。

- 對於 Epic 3 的 stories——我也 YOLO 了它，但是使用了 Sonnet 3.7——只是想看看在 cursor 中使用一個非常不同的模型，story 輸出的品質有何不同。
