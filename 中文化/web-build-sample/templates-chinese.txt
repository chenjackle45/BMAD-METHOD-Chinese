==================== START: architecture-tmpl ====================
# {專案名稱} 架構文件

## 簡介 / 前言

{本文件概述整體專案架構，包含後端系統、共用服務以及非 UI 特定考量。其主要目標是作為 AI 驅動開發的指導性架構藍圖，確保一致性並遵循所選的模式與技術。

**與前端架構的關係：**
若專案包含重要的使用者介面，則一份獨立的前端架構文件（通常命名為 `front-end-architecture-tmpl.txt` 或類似名稱，並連結於「關鍵參考文件」章節）將詳述前端特定的設計，且必須與本文件一同使用。本文件記錄的核心技術堆疊選擇（請參閱「最終技術堆疊選型」）對整個專案（包含任何前端元件）均具決定性。}

## 目錄

{ 若有新增或移除章節及子章節，請更新此處 }

## 技術摘要

{ 提供一段簡短的段落，概述系統架構、關鍵元件、技術選擇以及使用的架構模式。參考 PRD 中的目標。 }

## 高階概觀

{ 描述主要的架構風格（例如：Monolith、Microservices、Serverless、Event-Driven），反映 PRD 中的決策。解釋 repository 結構（Monorepo/Polyrepo）。在概念層級解釋主要的使用者互動或資料流程。 }

{ 在此處插入高階 mermaid system context 或互動圖表 - 例如：Mermaid Class C4 Models Layer 1 和 2 }

## 採用的架構 / 設計模式

{ 列出為架構選擇的關鍵高階模式。這些基礎模式應儘早建立，因為它們指導元件設計、互動和技術選擇。 }

- **模式 1：** {例如：Serverless、Event-Driven、Microservices、CQRS} - _理由/參考：_ {簡述原因，或視需要連結至更詳細的說明}
- **模式 2：** {例如：Dependency Injection、Repository Pattern、Module Pattern} - _理由/參考：_ {...}
- **模式 N：** {...}

## 元件檢視

{ 描述系統的主要邏輯元件或服務及其職責，反映已決定的整體架構（例如：不同的 microservices、monolith 中的模組、monorepo 中的套件）以及採用的架構模式。解釋它們如何協作。 }

- 元件 A：{職責說明}

{ 若有助益，可在此處插入元件圖 - 例如：使用 Mermaid graph TD 或 C4 Model Container/Component Diagram}

- 元件 N...：{職責說明}

{ 若有助益，可在此處插入元件圖 - 例如：使用 Mermaid graph TD 或 C4 Model Container/Component Diagram }

## 專案結構

{提供一個 ASCII 或 Mermaid 圖表來表示專案的資料夾結構。以下為一般範例。若正在使用 `front-end-architecture-tmpl.txt`（或等效文件），它將包含前端部分的詳細結構（例如：在 `src/frontend/` 內或專用的 `frontend/` 根目錄中）。共用程式碼結構（例如：在 monorepo 的 `packages/` 目錄中）也應在此處詳述。}

```plaintext
{project-root}/
├── .github/                    # CI/CD 工作流程 (例如：GitHub Actions)
│   └── workflows/
│       └── main.yml
├── .vscode/                    # VSCode 設定 (選用)
│   └── settings.json
├── build/                      # 編譯輸出 (若適用，通常 git-ignored)
├── config/                     # 靜態設定檔 (若有)
├── docs/                       # 專案文件 (PRD、架構文件等)
│   ├── index.md
│   └── ... (其他 .md 檔案)
├── infra/                      # Infrastructure as Code (例如：CDK、Terraform)
│   └── lib/
│   └── bin/
├── node_modules/ / venv / target/ # 專案依賴項 (git-ignored)
├── scripts/                    # 工具腳本 (建置、部署輔助程式等)
├── src/                        # 應用程式原始碼
│   ├── backend/                # 後端特定應用程式碼 (若存在獨立前端)
│   │   ├── core/               # 核心商業邏輯、領域模型
│   │   ├── services/           # 商業服務、協調器
│   │   ├── adapters/           # 外部系統 (資料庫、API) 的適配器
│   │   ├── controllers/ / routes/ # API 端點處理常式
│   │   └── main.ts / app.py    # 後端應用程式進入點
│   ├── frontend/               # 預留位置：若使用，詳情請參閱前端架構文件
│   ├── shared/ / common/       # 共用程式碼 (例如：類型、工具程式、領域模型 (若適用))
│   │   └── types/
│   └── main.ts / index.ts / app.ts # 主要應用程式進入點 (若未使用上述後端/前端分離)
├── stories/                    # 為開發產生的 story 檔案 (選用)
│   └── epic1/
├── test/                       # 自動化測試
│   ├── unit/                   # 單元測試 (對應 src 結構)
│   ├── integration/            # 整合測試
│   └── e2e/                    # 端對端測試
├── .env.example                # 環境變數範例
├── .gitignore                  # Git 忽略規則
├── package.json / requirements.txt / pom.xml # 專案資訊清單與依賴項
├── tsconfig.json / pyproject.toml # 特定語言設定 (若適用)
├── Dockerfile                  # Docker 建置說明 (若適用)
└── README.md                   # 專案概觀與設定說明
```

(根據實際專案類型調整範例樹狀結構 - 例如，Python 專案會有 requirements.txt 等。上述結構說明了具有獨立前端的專案的可能分離方式；對於較簡單的專案或 API，`src/` 結構可能會更扁平。)

### 關鍵目錄說明

- docs/: 包含所有專案規劃與參考文件。
- infra/: 存放 Infrastructure as Code 定義 (例如：AWS CDK、Terraform)。
- src/: 包含主要應用程式原始碼。可能根據專案複雜度以及是否使用獨立的前端架構文件再細分 (例如：`backend/`、`frontend/`、`shared/`)。
- src/backend/core/ / src/core/ / src/domain/: 核心商業邏輯、實體、使用案例，獨立於框架/外部服務。
- src/backend/adapters/ / src/adapters/ / src/infrastructure/: 實作細節、與資料庫、雲端 SDK、框架的互動。
- src/backend/controllers/ / src/routes/ / src/pages/: API 請求或 UI 檢視的進入點 (若 UI 簡單且未在獨立的前端結構中)。
- test/: 包含所有自動化測試，適用時對應 src/ 結構。

### 備註

{提及任何特定的建置輸出路徑、編譯器設定指標或其他相關的結構性備註。}

## API 參考

### 取用的外部 API

{系統互動的每個外部 API 皆重複此區段。}

#### {外部服務名稱} API

- **目的：** {系統為何使用此 API？}
- **基礎 URL：**
  - Production: `{URL}`
  - Staging/Dev: `{URL}`
- **驗證：** {描述方法 - 例如：標頭中的 API 金鑰 (標頭名稱：`X-API-Key`)、OAuth 2.0 Client Credentials、Basic Auth。金鑰名稱請參考 `docs/environment-vars.md`。}
- **使用的關鍵端點：**
  - **`{HTTP 方法} {/path/to/endpoint}`：**
    - 說明：{此端點的作用為何？}
    - 請求參數：{查詢參數、路徑參數}
    - 請求主體結構：{提供行內 JSON 結構，或僅在結構異常龐大或複雜時連結至 `docs/data-models.md` 中的詳細定義。}
    - 請求範例：`{程式碼區塊}`
    - 成功回應結構 (代碼：`200 OK`)：{提供行內 JSON 結構，或僅在非常複雜時連結至 `docs/data-models.md` 中的詳細定義。}
    - 錯誤回應結構 (代碼：`4xx`、`5xx`)：{提供行內 JSON 結構，或僅在非常複雜時連結至 `docs/data-models.md` 中的詳細定義。}
    - 回應範例：`{程式碼區塊}`
  - **`{HTTP 方法} {/another/endpoint}`：** {...}
- **速率限制：** {若已知}
- **官方文件連結：** {URL}

### 提供的內部 API (若適用)

{若系統公開自己的 API (例如：在 microservices 架構中或供 UI 前端使用)。每個 API 皆重複此區段。}

#### {內部 API / 服務名稱} API

- **目的：** {此 API 提供何種服務？}
- **基礎 URL：** {例如：`/api/v1/...`}
- **驗證/授權：** {描述存取控制方式。}
- **端點：**
  - **`{HTTP 方法} {/path/to/endpoint}`：**
    - 說明：{此端點的作用為何？}
    - 請求參數：{...}
    - 請求主體結構：{提供行內 JSON 結構，或僅在非常複雜時連結至 `docs/data-models.md` 中的詳細定義。}
    - 成功回應結構 (代碼：`200 OK`)：{提供行內 JSON 結構，或僅在非常複雜時連結至 `docs/data-models.md` 中的詳細定義。}
    - 錯誤回應結構 (代碼：`4xx`、`5xx`)：{提供行內 JSON 結構，或僅在非常複雜時連結至 `docs/data-models.md` 中的詳細定義。}
  - **`{HTTP 方法} {/another/endpoint}`：** {...}

## 資料模型

### 核心應用程式實體 / 領域物件

{定義應用程式處理的主要物件/概念。每個關鍵實體皆重複此子區段。}

#### {實體名稱，例如：User、Order、Product}

- **說明：** {此實體代表什麼？}
- **結構 / 介面定義：**
  ```typescript
  // 使用 TypeScript Interface 的範例
  export interface {EntityName} {
    id: string; // {說明，例如：唯一識別碼}
    propertyName: string; // {說明}
    optionalProperty?: number; // {說明}
    // ... 其他屬性
  }
  ```
- **驗證規則：** {列出基本類型以外的任何特定驗證規則 - 例如：最大長度、格式、範圍。}

### API Payload 結構 (若不同)

{僅當結構與核心實體不同且未在 API 參考區段的 API 端點定義中完整詳述時，才在此處定義結構。盡可能直接在 API 中詳述請求/回應結構。此區段適用於可能跨多個內部 API 使用或與核心持久化實體顯著不同的複雜、可重複使用的 payload 結構。}

#### {API 端點 / 目的，例如：建立訂單請求，視需要重複此區段}

- **結構 / 介面定義：**
  ```typescript
  // 範例
  export interface CreateOrderRequest {
    customerId: string;
    items: { productId: string; quantity: number }[];
    // ...
  }
  ```

### 資料庫結構 (若適用)

{若使用資料庫，定義資料表結構或文件資料庫結構。視需要重複。}

#### {資料表 / 集合名稱}

- **目的：** {此資料表儲存何種資料？}
- **結構定義：**
  ```sql
  -- SQL 範例
  CREATE TABLE {TableName} (
    id VARCHAR(36) PRIMARY KEY,
    column_name VARCHAR(255) NOT NULL,
    numeric_column DECIMAL(10, 2),
    -- ... 其他欄位、索引、約束
  );
  ```
  _(或者，使用 ORM 模型定義、NoSQL 文件結構等。)_

## 核心工作流程 / 循序圖

{ 使用 mermaid 循序圖說明關鍵或複雜的工作流程。可以有將整個專案串聯起來的高階圖表，也可以有較小的 epic 層級循序圖。 }

## 最終技術堆疊選型

{ 此區段概述專案的最終技術選擇。這些選擇應在透徹了解專案需求、元件、資料模型和核心工作流程後做出。Architect Agent 應引導使用者完成這些決策，確保每個選擇都有充分理由並準確記錄在下表中。

此表格是所有技術選型的**唯一真實來源**。其他架構文件（例如：前端架構）必須參考這些選擇並詳細說明其特定應用，而非重新定義它們。

此處需要討論並最終確定的關鍵決策，然後將在下方的詳細堆疊表格中擴展並正式記錄，包括以下考量：

- 偏好的入門範本前端：{ 範本或入門專案的 URL，若有使用 }
- 偏好的入門範本後端：{ 範本或入門專案的 URL，若有使用 }
- 主要語言與版本：{例如：TypeScript 5.x、Python 3.11 - 指定確切版本，例如：`5.2.3`}
- 主要執行環境與版本：{例如：Node.js 22.x - 指定確切版本，例如：`22.0.1`}

必須是明確的選型；請勿列出開放式選擇（例如：對於網頁抓取，選擇一個工具，而非兩個）。指定確切版本（例如：`18.2.0`）。若使用「最新版」，則表示本文件上次更新時的最新穩定版本，且應記錄特定版本（例如：`xyz-library@2.3.4`）。強烈建議鎖定版本，以避免 AI agent 發生非預期的重大變更。 }

| 類別             | 技術              | 版本 / 詳細資料 | 說明 / 目的                   | 理由 (選填) |
| :------------------- | :---------------------- | :---------------- | :-------------------------------------- | :----------------------- |
| **語言**        | {例如：TypeScript}      | {例如：5.x}       | {後端/前端主要語言} | {為何選擇此語言？}     |
|                      | {例如：Python}          | {例如：3.11}      | {用於資料處理、機器學習}          | {...}                    |
| **執行環境**          | {例如：Node.js}         | {例如：22.x}      | {伺服器端執行環境}     | {...}                    |
| **框架**       | {例如：NestJS}          | {例如：10.x}      | {後端 API 框架}                 | {為何選擇此框架？}    |
|                      | {例如：React}           | {例如：18.x}      | {前端 UI 函式庫}                   | {...}                    |
| **資料庫**        | {例如：PostgreSQL}      | {例如：15}        | {主要關聯式資料儲存}         | {...}                    |
|                      | {例如：Redis}           | {例如：7.x}       | {快取、session 儲存}              | {...}                    |
| **雲端平台**   | {例如：AWS}             | {N/A}             | {主要雲端供應商}                | {...}                    |
| **雲端服務**   | {例如：AWS Lambda}      | {N/A}             | {Serverless 運算}                    | {...}                    |
|                      | {例如：AWS S3}          | {N/A}             | {物件儲存 (用於資產/狀態)}       | {...}                    |
|                      | {例如：AWS EventBridge} | {N/A}             | {事件匯流排 / 排程任務}           | {...}                    |
| **基礎架構**   | {例如：AWS CDK}         | {例如：最新版}    | {Infrastructure as Code 工具}           | {...}                    |
|                      | {例如：Docker}          | {例如：最新版}    | {容器化}                      | {...}                    |
| **UI 函式庫**     | {例如：Material UI}     | {例如：5.x}       | {React 元件函式庫}               | {...}                    |
| **狀態管理** | {例如：Redux Toolkit}   | {例如：最新版}    | {前端狀態管理}             | {...}                    |
| **測試**          | {例如：Jest}            | {例如：最新版}    | {單元/整合測試框架}    | {...}                    |
|                      | {例如：Playwright}      | {例如：最新版}    | {端對端測試框架}          | {...}                    |
| **CI/CD**            | {例如：GitHub Actions}  | {N/A}             | {持續整合/持續部署}     | {...}                    |
| **其他工具**      | {例如：LangChain.js}    | {例如：最新版}    | {LLM 互動函式庫}               | {...}                    |
|                      | {例如：Cheerio}         | {例如：最新版}    | {HTML 解析/抓取}                 | {...}                    |

## 基礎架構與部署概觀

- 雲端供應商：{例如：AWS、Azure、GCP、On-premise}
- 使用的核心服務：{列出關鍵的受管理服務 - 例如：Lambda、S3、Kubernetes Engine、RDS、Kafka}
- Infrastructure as Code (IaC)：{使用的工具 - 例如：AWS CDK、Terraform...} - 位置：{IaC 程式碼 repository/目錄連結}
- 部署策略：{例如：具有自動化升級的 CI/CD pipeline、Blue/Green、Canary} - 工具：{例如：Jenkins、GitHub Actions、GitLab CI}
- 環境：{列出環境 - 例如：Development、Staging、Production}
- 環境升級：{描述步驟，例如：`dev` -> `staging` (手動核准 / 自動化測試通過) -> `production` (測試通過後自動化並可選用手動核准)}
- 回復策略：{例如：部署後健康狀態檢查失敗時自動回復、透過 CI/CD 工作手動觸發、IaC 狀態回復。指定主要機制。}

## 錯誤處理策略

- **一般方法：** {例如：使用例外作為主要機制、針對特定模組傳回錯誤碼/元組、明確定義的自訂錯誤類型階層。}
- **記錄：**
  - 函式庫/方法：{例如：`console.log/error` (Node.js)、Python `logging` 模組搭配 `structlog`、專用記錄函式庫如 `Pino` 或 `Serilog`。指定所選函式庫。}
  - 格式：{例如：JSON、帶有時間戳記和嚴重性的純文字。建議使用 JSON 進行結構化記錄。}
  - 層級：{例如：DEBUG、INFO、WARN、ERROR、CRITICAL。指定每個層級的標準用法。}
  - 上下文：{必須包含哪些上下文資訊？例如：Correlation ID、User ID (若適用且安全)、Service Name、Operation Name、Key Parameters (已清理)。}
- **特定處理模式：**
  - 外部 API 呼叫：{定義重試機制 (例如：指數退避、最大重試次數 - 若強制使用如 `Polly` 或 `tenacity` 等函式庫，請指定)、斷路器模式用法 (例如：使用 `resilience4j` 或等效函式庫 - 指定是否使用及如何使用)、逾時設定 (連線和讀取逾時)。API 錯誤 (4xx、5xx) 如何轉換或傳播？}
  - 內部錯誤 / 商業邏輯例外：{如何將內部錯誤轉換為使用者可見的錯誤 (若適用) (例如：帶有唯一 ID 以供支援的通用錯誤訊息、特定錯誤碼)。是否有定義的商業例外類別？}
  - 交易管理：{在多步驟操作發生錯誤時確保資料一致性的方法，例如：資料庫交易 (若非預設，請指定隔離等級)、用於分散式交易的 Saga 模式 (指定協調器/編排和補償邏輯)。}

## 編碼標準

{這些標準對 AI agent 和人工開發者產生的所有程式碼皆為強制性。除非在本節或連結的附錄中明確核准並記錄為例外，否則不允許偏離。}

- **主要執行環境：** {例如：Node.js 22.x、Lambda 的 Python Runtime - 請參考最終技術堆疊}
- **風格指南與 Linter：** {例如：ESLint 搭配 Airbnb 設定 + Prettier；Black、Flake8、MyPy；Go fmt、golint。指定所選工具並連結至設定檔 (例如：`.eslintrc.js`、`pyproject.toml`)。Linter 規則為強制性，除非有原因，否則不得停用。}
- **命名慣例：**
  - 變數：`{例如：camelCase (JavaScript/TypeScript/Java)、snake_case (Python/Ruby)}`
  - 函式/方法：`{例如：camelCase (JavaScript/TypeScript/Java)、snake_case (Python/Ruby)}`
  - 類別/類型/介面：`{例如：PascalCase}`
  - 常數：`{例如：UPPER_SNAKE_CASE}`
  - 檔案：`{例如：kebab-case.ts (TypeScript)、snake_case.py (Python)、PascalCase.java (Java)。針對每種語言具體說明。}`
  - 模組/套件：`{例如：camelCase 或 snake_case。針對每種語言具體說明。}`
- **檔案結構：** 遵循「專案結構」一節和前端架構文件 (若適用) 中定義的佈局。
- **單元測試檔案組織：** {例如：`*.test.ts`/`*.spec.ts` 與原始檔案並存；`test_*.py` 在平行的 `tests/` 目錄中。指定所選慣例。}
- **非同步操作：** {例如：在 TypeScript/JavaScript/Python 中一律對基於 promise 的操作使用 `async`/`await`；在 Go 中使用 Goroutines/Channels 並具備清晰的錯誤傳播和完成模式；若使用，則為 Java `CompletableFuture` 或 Project Reactor/RxJava。}
- **類型安全：** {例如：利用 TypeScript strict mode (所有旗標啟用)；Python 類型提示 (由 MyPy 強制執行)；Go 靜態類型；Java 泛型並避免使用原始類型。所有新程式碼必須嚴格類型化。}
  - _類型定義：_ {位置，例如：`src/common/types.ts`、共用套件或並存。關於使用 `any` 或等效類型的政策 (強烈不建議，需要理由)。}
- **註解與文件：**
  - 程式碼註解：{對程式碼註解的期望：針對複雜邏輯解釋「為何」，而非「為何」。避免多餘的註解。使用標準格式，如 JSDoc、TSDoc、Python docstrings (Google/NumPy 風格)、GoDoc、JavaDoc。}
  - README：{每個模組/套件/服務若非不言自明，應有 README 解釋其目的、設定和用法。}
- **依賴管理：** {使用的工具 - 例如：npm/yarn、pip/poetry、Go modules、Maven/Gradle。新增依賴項的政策 (例如：核准流程、檢查現有替代方案、安全性漏洞掃描)。指定版本控制策略 (例如：偏好鎖定版本、對修補程式使用波浪號 `~`、對次要更新使用插入號 `^` - 具體說明)。}

### 詳細語言與框架慣例

{對於在「最終技術堆疊選型」中選擇的每種主要語言和框架，**必須**遵守以下特定慣例。若所選技術未列於下方，則表示遵循其標準、廣為接受的最佳實務以及本文件中的一般準則。}

#### `{語言/框架 1 名稱，例如：TypeScript/Node.js}` 特定事項：

- **不可變性：** `{例如：「一律偏好不可變的資料結構。對物件/陣列字面值使用 `Readonly<T>`、`ReadonlyArray<T>`、`as const`。避免直接修改作為 props 或 state 傳遞的物件/陣列。考慮對複雜的 state 更新使用 Immer 等函式庫。」}`
- **函數式 vs. 物件導向：** `{例如：「在實際可行的情况下，偏好對資料轉換和商業邏輯使用函數式程式設計結構 (map、filter、reduce、純函式)。對具有明確 state/職責的實體、服務，或當框架慣例 (例如：NestJS) 要求時，使用類別。」}`
- **錯誤處理特定事項：** `{例如：「一律對 `throw` 使用 `Error` 物件或其擴充。確保 `Promise` rejections 一律為 `Error` 物件。對領域特定的錯誤使用繼承自基礎 `AppError` 的自訂錯誤類別。」}`
- **Null/Undefined 處理：** `{例如：「必須啟用嚴格的 null 檢查 (`strictNullChecks`)。避免使用 `!` non-null assertion 運算子；偏好明確檢查、optional chaining (`?.`) 或 nullish coalescing (`??`)。為選用的函式參數和傳回類型定義清晰的策略。」}`
- **模組系統：** `{例如：「僅使用 ESModules (`import`/`export`)。避免在新程式碼中使用 CommonJS (`require`/`module.exports`)。」}`
- **記錄特定事項：** `{例如：「使用所選的結構化記錄函式庫。記錄訊息必須包含 correlation ID。請勿記錄敏感的 PII。使用適當的記錄層級。」}`
- **框架慣用語 (例如：針對 NestJS/Express)：** `{例如：「NestJS：一律使用裝飾器定義模組、控制器、服務、DTO。嚴格遵守定義的模組結構和依賴注入模式。Express：定義中介軟體模式、路由結構。」}`
- **關鍵函式庫使用慣例：** `{例如：「使用 Axios 時，建立單一的已設定實例。對於日期/時間，使用 {date-fns/Luxon/Day.js} 並避免對操作使用原生的 `Date` 物件。」}`
- **應避免的程式碼產生反模式：** `{例如：「避免過度巢狀的條件邏輯 (最多 2-3 層)。避免使用單字母變數名稱 (除了像 `i`、`j`、`k` 這樣不重要的迴圈計數器)。請勿撰寫繞過框架安全性功能的程式碼 (例如：ORM 查詢產生器)。」}`

#### `{語言/框架 2 名稱，例如：Python}` 特定事項：

- **不可變性：** `{例如：「對不可變序列使用元組。對於類別，考慮 `@dataclass(frozen=True)`。注意可變的預設引數。」}`
- **函數式 vs. 物件導向：** `{例如：「使用類別表示實體和服務。對無狀態操作使用函式。列表推導式/產生器表達式因其可讀性而優於 `map/filter`。」}`
- **錯誤處理特定事項：** `{例如：「一律引發繼承自基礎 `AppException` 的特定自訂例外。適當使用 `try-except-else-finally` 區塊。避免使用廣泛的 `except Exception:` 子句，除非重新引發或進行特定處理。」}`
- **資源管理：** `{例如：「一律對檔案或資料庫連線等資源使用 `with` 陳述式，以確保它們被正確關閉。」}`
- **類型提示：** `{例如：「所有新的函式和方法都必須有完整的類型提示。在 CI 中執行 MyPy。力求 `disallow_untyped_defs = True`。」}`
- **記錄特定事項：** `{例如：「使用設定為結構化輸出的 `logging` 模組 (例如：搭配 `python-json-logger`)。包含 correlation ID。」}`
- **框架慣用語 (例如：針對 Django/Flask/FastAPI)：** `{例如：「Django：遵循 fat models, thin views 模式。使用 ORM 慣例。FastAPI：利用 Pydantic 處理請求/回應模型，並對服務使用依賴注入。」}`
- **關鍵函式庫使用慣例：** `{例如：「對於 HTTP 請求，使用具有明確逾時設定的 `httpx` 或 `requests`。對於資料操作，在適當情況下偏好 `pandas`，但要注意效能。」}`

#### `{視需要新增更多語言/框架區段...}`

- **{考量受過訓練的 LLM Dev Agent 可能會針對所選語言技術和平台隨機產生的其他事項，應在此處提醒}**

## 整體測試策略

{此區段概述專案的全面測試策略，所有 AI 產生和人工撰寫的程式碼都必須遵守。它補充了「最終技術堆疊選型」中列出的測試工具。}

- **工具：** {重申技術堆疊中的主要測試框架和函式庫，例如：Jest、Playwright、PyTest、JUnit、Testcontainers。}
- **單元測試：**
  - **範圍：** {在隔離環境中測試個別函式、方法、類別或小型模組。專注於商業邏輯、演算法和轉換規則。}
  - **位置：** {例如：`*.test.ts`/`*.spec.ts` 與原始檔案並存；`test_*.py` 在平行的 `tests/` 目錄中，遵循語言慣例。}
  - **Mocking/Stubbing：** {指定所選的 mocking 函式庫 (例如：Jest mocks、Python 中的 `unittest.mock`、Java 的 Mockito)。Mock 所有外部依賴項 (網路呼叫、檔案系統、資料庫、時間)。}
  - **AI Agent 職責：** {AI Agent 必須為任何新增或修改的程式碼產生涵蓋所有公用方法、重要邏輯路徑、邊緣案例和錯誤條件的單元測試。}
- **整合測試：**
  - **範圍：** {測試應用程式邊界內多個元件或服務之間的互動。例如：API 端點到服務層到資料庫 (使用測試資料庫或記憶體內版本)。}
  - **位置：** {例如：`/tests/integration` 或 `/src/integration-test` (Java)。}
  - **環境：** {指定如何處理依賴項 (例如：用於資料庫/外部服務的 Testcontainers、記憶體內資料庫、專用測試環境)。}
  - **AI Agent 職責：** {AI Agent 可能會根據規格為關鍵服務互動或 API 端點產生整合測試。}
- **端對端 (E2E) 測試：**
  - **範圍：** {從使用者角度驗證系統的完整使用者流程或關鍵路徑 (例如：UI 互動、API 呼叫順序)。}
  - **工具：** {重申技術堆疊中的 E2E 測試工具 (例如：Playwright、Cypress、Selenium)。}
  - **AI Agent 職責：** {AI Agent 可能會根據 user stories 或 BDD 情境產生 E2E 測試 stub 或腳本。專注於關鍵的 happy path 和主要的錯誤情境。}
- **測試覆蓋率：**
  - **目標：** {指定目標程式碼覆蓋率 (若有) (例如：單元測試的 80% 行/分支覆蓋率)。這是一個指導方針；測試品質優先於原始覆蓋率數字。}
  - **測量：** {用於覆蓋率報告的工具 (例如：Istanbul/nyc、Coverage.py、JaCoCo)。}
- **Mocking/Stubbing 策略 (一般)：** {除了特定測試類型外，概述一般原則。例如：「在能提高測試清晰度和可維護性的情況下，偏好使用 fake 或 test double 而非廣泛的 mocking。力求測試快速、可靠且隔離。」}
- **測試資料管理：** {如何建立、管理和隔離測試資料？例如：factories、fixtures、設定/拆卸腳本、專用測試資料產生工具。}

## 安全性最佳實務

{概述與程式碼庫相關的關鍵安全性考量。這些是強制性的，AI agent 必須在開發過程中積極處理。}

- **輸入清理/驗證：** {指定所有外部輸入 (API 請求、使用者提供的資料、檔案上傳) 的函式庫/方法。例如：「對所有 API 輸入使用 class-validator 搭配 NestJS DTO；所有驗證規則必須在 DTO 中定義。」對於其他語言：「對所有外部輸入使用 {validation_library}；定義結構和約束。」驗證必須在處理前於邊界進行。}
- **輸出編碼：** {指定在何處以及如何執行輸出編碼以防止 XSS 和其他注入攻擊。例如：「在 HTML 範本中呈現的所有動態資料必須由範本引擎進行上下文自動跳脫 (指定引擎並確認預設行為)。若手動產生 HTML/XML/JSON，請使用核准的編碼函式庫，如 {encoder_library_name}。」}
- **機密管理：** {關於不同環境的儲存，請參考 `docs/environment-vars.md`。在程式碼中，_僅_透過指定的設定模組/服務存取機密。切勿寫死機密、將其包含在原始碼控制中或記錄它們。若適用，對本機開發使用特定工具 (例如：Doppler、未提交的 .env 檔案)。}
- **依賴項安全性：** {檢查易受攻擊依賴項的政策。例如：「在 CI 中執行自動化漏洞掃描 (例如：`npm audit`、`pip-audit`、Snyk、Dependabot alerts)。根據嚴重性及時更新易受攻擊的依賴項。」新增依賴項的政策 (審查流程)。}
- **驗證/授權檢查：** {應在何處以及如何強制執行？例如：「所有 API 端點 (明確公開的端點除外) 都必須使用中央驗證模組/中介軟體強制執行驗證。授權 (權限/角色檢查) 必須在服務層或受保護資源的進入點執行。」定義實作這些檢查的模式。}
- **最小權限原則 (實作)：** {例如：「資料庫連線使用者對其存取的特定資料表/結構，必須僅具有必要的權限 (SELECT、INSERT、UPDATE、DELETE)。雲端服務的 IAM 角色必須嚴格限定於所需的動作和資源。」}
- **API 安全性 (一般)：** {例如：「強制執行 HTTPS。實作速率限制和節流 (指定工具/方法)。使用標準 HTTP 安全性標頭 (CSP、HSTS、X-Frame-Options 等 - 指定哪些以及其設定)。遵循 REST/GraphQL 安全性最佳實務。」}
- **錯誤處理與資訊洩漏：** {確保錯誤訊息不會向終端使用者洩漏敏感資訊 (堆疊追蹤、內部路徑、詳細的 SQL 錯誤)。在伺服器端記錄詳細錯誤，向用戶端提供通用訊息或錯誤 ID。}
- **定期安全性稽核/測試：** {提及是否計畫進行，例如：滲透測試、在 CI 中使用靜態/動態分析工具 (SAST/DAST)。}
- **{其他相關實務，例如：檔案上傳安全性、Session 管理安全性、若有特定需求，則除了 HTTPS 外的靜態和傳輸中資料加密。}**

## 關鍵參考文件

{ 若有 }

## 變更記錄

| 變更 | 日期 | 版本 | 說明 | 作者 |
| ------ | ---- | ------- | ----------- | ------ |

--- 以下，提示 Design Architect (若專案有 UI) 產生前端架構 ----

==================== END: architecture-tmpl ====================


==================== START: doc-sharding-tmpl ====================
# 文件分片計畫範本

此計畫指導 agent 如何在其 Librarian Phase 將大型原始文件分解為更小、更細緻的檔案。agent 將參考此計畫來識別原始文件、要擷取的特定區段以及分片內容的目標檔名。

---

## 1. 原始文件：PRD (專案需求文件)

- **給 Agent 的備註：** 與使用者確認 PRD 的確切檔名 (例如：`PRD.md`、`ProjectRequirements.md`、`prdx.y.z.md`)。

### 1.1. Epic 細化

- **指示：** 對於 PRD 中識別的每個 Epic：
- **要複製的來源區段：** Epic 的完整文字，包括其主要說明、目標以及該 Epic 下所有相關的 user stories 或詳細需求。確保從類似「**Epic X：**」的標題開始擷取內容，直到下一個此類標題或「Epic 概觀」區段結束。
- **目標檔案模式：** `docs/epic-<id>.md`
  - _Agent 備註：`<id>` 應對應 Epic 編號。_

---

## 2. 原始文件：主要架構文件

- **給 Agent 的備註：** 與使用者確認確切檔名 (例如：`architecture.md`、`SystemArchitecture.md`)。

### 2.1. 核心架構細項

- **要複製的來源區段：** 詳述「API 參考」、「API 端點」或「服務介面」的區段。
- **目標檔案：** `docs/api-reference.md`

- **要複製的來源區段：** 詳述「資料模型」、「資料庫結構」或「實體定義」的區段。
- **目標檔案：** `docs/data-models.md`

- **要複製的來源區段：** 標題為「環境變數文件」、「設定」、「部署參數」的區段，或若未找到專用區段，則為「基礎架構與部署概觀」內的相關子區段。
- **目標檔案：** `docs/environment-vars.md`

  - _Agent 備註：優先使用專用的「環境變數」區段或連結的 `environment-vars.md` 來源 (若有)。若無，則從「基礎架構與部署概觀」中擷取相關設定詳細資料。此分片用於特定的變數定義和用法。_

- **要複製的來源區段：** 詳述「專案結構」的區段。
- **目標檔案：** `docs/project-structure.md`

  - _Agent 備註：若專案涉及多個 repositories (非 monorepo)，請確保此檔案清楚描述每個相關 repository 的結構，或視需要連結至子檔案。_

- **要複製的來源區段：** 詳述「技術堆疊」、「關鍵技術」、「函式庫與框架」或「最終技術堆疊選型」的區段。
- **目標檔案：** `docs/tech-stack.md`

- **要複製的來源區段：** 詳述「編碼標準」、「開發準則」、「最佳實務」、「測試策略」、「測試決策」、「QA 流程」、「整體測試策略」、「錯誤處理策略」和「安全性最佳實務」的區段。
- **目標檔案：** `docs/operational-guidelines.md`

  - _Agent 備註：此檔案整合了幾個關鍵的營運層面。確保來自每個來源區段 (「編碼標準」、「測試策略」、「錯誤處理策略」、「安全性最佳實務」) 的內容在此文件中的各自 H3 (###) 或 H4 (####) 標題下清楚劃分。_

- **要複製的來源區段：** 標題為「元件檢視」的區段 (包含「採用的架構 / 設計模式」等子區段)。
- **目標檔案：** `docs/component-view.md`

- **要複製的來源區段：** 標題為「核心工作流程 / 循序圖」的區段 (包含所有子圖表)。
- **目標檔案：** `docs/sequence-diagrams.md`

- **要複製的來源區段：** 標題為「基礎架構與部署概觀」的區段。
- **目標檔案：** `docs/infra-deployment.md`

  - _Agent 備註：此為更廣泛的概觀，與特定的 `docs/environment-vars.md` 不同。_

- **要複製的來源區段：** 標題為「關鍵參考文件」的區段。
- **目標檔案：** `docs/key-references.md`

---

## 3. 原始文件：前端特定文件

- **給 Agent 的備註：** 與使用者確認檔名 (例如：`front-end-architecture.md`、`front-end-spec.md`、`ui-guidelines.md`)。可能存在多個前端文件。

### 3.1. 前端細項

- **要複製的來源區段：** 詳述「前端專案結構」或「詳細前端目錄結構」的區段。
- **目標檔案：** `docs/front-end-project-structure.md`

- **要複製的來源區段：** 詳述「UI 風格指南」、「品牌準則」、「視覺設計規格」或「樣式設定方法」的區段。
- **目標檔案：** `docs/front-end-style-guide.md`

  - _Agent 備註：此區段可能是子區段或參考其他文件 (例如：`ui-ux-spec.txt`)。擷取前端架構文件本身定義的核心樣式設定理念和方法。_

- **要複製的來源區段：** 詳述「元件函式庫」、「可重複使用 UI 元件指南」、「Atomic Design 元素」或「元件分解與實作細節」的區段。
- **目標檔案：** `docs/front-end-component-guide.md`

- **要複製的來源區段：** 詳述「前端編碼標準」的區段 (特別針對 UI 開發，例如：JavaScript/TypeScript 風格、CSS 命名慣例、前端的無障礙最佳實務)。
- **目標檔案：** `docs/front-end-coding-standards.md`

  - _Agent 備註：可能不存在專用的頂層區段。若未找到，此分片可能為空，或需要與主要架構的編碼標準交叉參考。擷取任何提及的前端特定編碼慣例。_

- **要複製的來源區段：** 標題為「深入狀態管理」的區段。
- **目標檔案：** `docs/front-end-state-management.md`

- **要複製的來源區段：** 標題為「API 互動層」的區段。
- **目標檔案：** `docs/front-end-api-interaction.md`

- **要複製的來源區段：** 標題為「路由策略」的區段。
- **目標檔案：** `docs/front-end-routing-strategy.md`

- **要複製的來源區段：** 標題為「前端測試策略」的區段。
- **目標檔案：** `docs/front-end-testing-strategy.md`

---

關鍵：**索引管理：** 建立檔案後，視需要更新 `docs/index.md` 以參考並描述每個文件 - 請勿提及細項或其分片來源，僅說明文件目的 - 因為索引也可能包含其他文件參考。

==================== END: doc-sharding-tmpl ====================


==================== START: front-end-architecture-tmpl ====================
# {專案名稱} 前端架構文件

## 目錄

{ 若有新增或移除章節及子章節，請更新此處 }

- [簡介](#introduction)
- [整體前端理念與模式](#overall-frontend-philosophy--patterns)
- [詳細前端目錄結構](#detailed-frontend-directory-structure)
- [元件分解與實作細節](#component-breakdown--implementation-details)
  - [元件命名與組織](#component-naming--organization)
  - [元件規格範本](#template-for-component-specification)
- [深入狀態管理](#state-management-in-depth)
  - [Store 結構 / Slices](#store-structure--slices)
  - [關鍵 Selectors](#key-selectors)
  - [關鍵 Actions / Reducers / Thunks](#key-actions--reducers--thunks)
- [API 互動層](#api-interaction-layer)
  - [Client/Service 結構](#clientservice-structure)
  - [錯誤處理與重試 (前端)](#error-handling--retries-frontend)
- [路由策略](#routing-strategy)
  - [路由定義](#route-definitions)
  - [路由守衛 / 保護](#route-guards--protection)
- [建置、打包與部署](#build-bundling-and-deployment)
  - [建置流程與腳本](#build-process--scripts)
  - [關鍵打包最佳化](#key-bundling-optimizations)
  - [部署至 CDN/Hosting](#deployment-to-cdnhosting)
- [前端測試策略](#frontend-testing-strategy)
  - [元件測試](#component-testing)
  - [UI 整合/流程測試](#ui-integrationflow-testing)
  - [端對端 UI 測試工具與範圍](#end-to-end-ui-testing-tools--scope)
- [無障礙 (AX) 實作細節](#accessibility-ax-implementation-details)
- [效能考量](#performance-considerations)
- [國際化 (i18n) 與本地化 (l10n) 策略](#internationalization-i18n-and-localization-l10n-strategy)
- [Feature Flag 管理](#feature-flag-management)
- [前端安全性考量](#frontend-security-considerations)
- [瀏覽器支援與漸進式增強](#browser-support-and-progressive-enhancement)
- [變更記錄](#change-log)

## 簡介

{ 本文件詳細說明 {專案名稱} 前端的技術架構。它補充了主要的 {專案名稱} 架構文件和 UI/UX 規格。本文件詳細說明前端架構，並**以主要 {專案名稱} 架構文件 (`docs/architecture.md` 或連結的等效文件) 中定義的基礎決策 (例如：整體技術堆疊、CI/CD、主要測試工具) 為基礎**。**前端特定的闡述或與一般模式的偏離必須在此處明確註明。**目標是為前端開發提供清晰的藍圖，確保一致性、可維護性，並與整體系統設計和使用者體驗目標保持一致。 }

- **主要架構文件連結 (必要)：** {例如：`docs/architecture.md`}
- **UI/UX 規格連結 (若存在則必要)：** {例如：`docs/front-end-spec.md`}
- **主要設計檔案連結 (Figma、Sketch 等) (若存在則必要)：** {來自 UI/UX 規格}
- **已部署的 Storybook / 元件展示連結 (若適用)：** {URL}

## 整體前端理念與模式

{ 描述為前端選擇的核心架構決策和模式。這應與主要架構文件中的「最終技術堆疊選型」保持一致，並考量整體系統架構的影響 (例如：monorepo vs. polyrepo、後端服務結構)。 }

- **框架與核心函式庫：** {例如：React 18.x 搭配 Next.js 13.x、Angular 16.x、Vue 3.x 搭配 Nuxt.js}。**這些源自主要架構文件中的「最終技術堆疊選型」。**本節詳細說明這些選擇如何*具體應用*於前端。
- **元件架構：** {例如：Atomic Design 原則、Presentational vs. Container 元件、使用特定元件函式庫如 Material UI、Tailwind CSS 的樣式設定方法。指定所選方法和任何關鍵函式庫。}
- **狀態管理策略：** {例如：Redux Toolkit、Zustand、Vuex、NgRx。簡要描述整體方法 – 全域 store、feature stores、context API 用法。**參考主要架構文件並在「深入狀態管理」一節中進一步詳述。**}
- **資料流程：** {例如：單向資料流程 (Flux/Redux 模式)、React Query/SWR 用於伺服器狀態。描述如何擷取、快取、傳遞給元件以及更新資料。}
- **樣式設定方法：** **{選擇的樣式設定解決方案，例如：Tailwind CSS / CSS Modules / Styled Components}**。設定檔：{例如：`tailwind.config.js`、`postcss.config.js`}。關鍵慣例：{例如：「Tailwind 的 utility-first 方法。自訂元件定義在 `src/styles/components.css` 中。`tailwind.config.js` 中的主題擴充在 `theme.extend` 下。對於 CSS Modules，檔案與元件並存，例如：`MyComponent.module.css`。」}
- **使用的關鍵設計模式：** {例如：Provider 模式、Hooks、Higher-Order Components、用於 API 呼叫的 Service 模式、Container/Presentational。這些模式必須一致應用。偏離需要理由和文件記錄。}

## 詳細前端目錄結構

{ 提供一個 ASCII 圖表來表示前端應用程式的特定資料夾結構 (例如：在 `src/` 或 `app/` 內，或若為 monorepo 的一部分，則為專用的 `frontend/` 根目錄)。這應詳細說明架構文件中概述的主要專案結構的前端部分。強調組織元件、頁面/檢視、服務、狀態、樣式、資產等的慣例。對於每個關鍵目錄，提供一句關於其用途的強制性說明。}

### 範例 - 非規範性 (適用於 React/Next.js 應用程式)

```plaintext
src/
├── app/                        # Next.js App Router：頁面/佈局/路由。必須包含路由區段、佈局和頁面元件。
│   ├── (features)/             # 基於功能的路由群組。必須將特定功能的相關路由分組。
│   │   └── dashboard/
│   │       ├── layout.tsx      # 特定於儀表板功能路由的佈局。
│   │       └── page.tsx        # 儀表板路由的進入頁面元件。
│   ├── api/                    # API 路由 (若使用 Next.js 後端功能)。必須包含用戶端呼叫的後端處理常式。
│   ├── globals.css             # 全域樣式。必須包含基礎樣式、CSS 變數定義、Tailwind base/components/utilities。
│   └── layout.tsx              # 整個應用程式的根佈局。
├── components/                 # 共用/可重複使用的 UI 元件。
│   ├── ui/                     # 基礎 UI 元素 (Button、Input、Card)。必須僅包含通用的、可重複使用的、展示性的 UI 元素，通常對應自設計系統。不得包含商業邏輯。
│   │   ├── Button.tsx
│   │   └── ...
│   ├── layout/                 # 佈局元件 (Header、Footer、Sidebar)。必須包含建構頁面佈局的元件，而非特定頁面內容。
│   │   ├── Header.tsx
│   │   └── ...
│   └── (feature-specific)/     # 特定於功能但可能在其內部重複使用的元件。這是 features/ 目錄內並存的替代方案。
│       └── user-profile/
│           └── ProfileCard.tsx
├── features/                   # 特定功能的邏輯、hooks、非全域狀態、服務以及該功能專用的元件。
│   └── auth/
│       ├── components/         # 驗證功能專用的元件。不得被其他功能匯入。
│       ├── hooks/              # 特定於「驗證」功能的自訂 React Hooks。跨功能重複使用的 Hooks 屬於 `src/hooks/`。
│       ├── services/           # 「驗證」功能的特定功能 API 互動或協調。
│       └── store.ts            # 特定功能的狀態 slice (例如：Redux slice)，若非全域 store 的一部分或本機狀態複雜。
├── hooks/                      # 全域/可共用的自訂 React Hooks。必須是通用的且可供多個功能/元件使用。
│   └── useAuth.ts
├── lib/ / utils/             # 工具函式、輔助程式、常數。必須包含純函式和常數，除非明確命名 (例如：`react-helpers.ts`)，否則不得有副作用或特定於框架的程式碼。
│   └── utils.ts
├── services/                   # 全域 API 服務用戶端或 SDK 設定。必須定義基礎 API 用戶端實例和核心資料擷取/變動服務。
│   └── apiClient.ts
├── store/                      # 全域狀態管理設定 (例如：Redux store、Zustand store)。
│   ├── index.ts                # 主要 store 設定與匯出。
│   ├── rootReducer.ts          # 若使用 Redux，則為根 reducer。
│   └── (slices)/               # 全域狀態 slices 的目錄 (若未與功能並存)。
├── styles/                     # 全域樣式、主題設定 (若未使用 `globals.css` 或類似檔案，或用於特定樣式系統如 SCSS partials)。
└── types/                      # 全域 TypeScript 類型定義/介面。必須包含跨多個功能/模組共用的類型。
    └── index.ts
```

### 前端結構備註：

{ 解釋結構背後的任何特定慣例或理由。例如：「若非全域可重複使用，元件與其功能並存以提高模組化程度。」AI Agent 必須嚴格遵守此定義的結構。新檔案必須根據這些說明放置在適當的目錄中。 }

## 元件分解與實作細節

{ 此區段概述定義 UI 元件的慣例和範本。大多數特定功能元件的詳細規格將隨著 user stories 的實作而產生。AI agent 在識別到要開發的新元件時，必須遵循下方的「元件規格範本」。 }

### 元件命名與組織

- **元件命名慣例：** **{例如：檔案和元件名稱使用 PascalCase：`UserProfileCard.tsx`}**。所有元件檔案都必須遵循此慣例。
- **組織：** {例如：「全域可重複使用的元件在 `src/components/ui/` 或 `src/components/layout/` 中。特定功能的元件與其功能目錄並存，例如：`src/features/feature-name/components/`。請參考詳細前端目錄結構。」}

### 元件規格範本

{ 對於從 UI/UX 規格和設計檔案 (Figma) 中識別出的每個重要 UI 元件，都必須提供以下詳細資料。每個元件重複此子區段。詳細程度必須足以讓 AI agent 或開發者以最少的歧義實作它。 }

#### 元件：`{ComponentName}` (例如：`UserProfileCard`、`ProductDetailsView`)

- **目的：** {簡要描述此元件的功能及其在 UI 中的角色。必須清晰簡潔。}
- **原始檔案：** {例如：`src/components/user-profile/UserProfileCard.tsx`。必須是確切路徑。}
- **視覺參考：** {連結至特定的 Figma frame/元件或 Storybook 頁面。必要。}
- **Props (屬性)：**
  { 列出元件接受的每個 prop。對於每個 prop，表格中的所有欄位都必須填寫。 }
  | Prop 名稱 | 類型                                      | 必要？ | 預設值 | 說明                                                                                                |
  | :-------------- | :---------------------------------------- | :-------- | :------------ | :--------------------------------------------------------------------------------------------------------- |
  | `userId`        | `string`                                  | 是       | N/A           | 要顯示的使用者 ID。必須是有效的 UUID。                                                     |
  | `avatarUrl`     | `string \| null`                          | 否        | `null`        | 使用者頭像圖片的 URL。若提供，必須是有效的 HTTPS URL。                                    |
  | `onEdit`        | `() => void`                              | 否        | N/A           | 觸發編輯動作時的回呼函式。                                                        |
  | `variant`       | `\'compact\' \| \'full\'`                     | 否        | `\'full\'`        | 控制卡片的顯示模式。                                                                   |
  | `{anotherProp}` | `{特定的基本類型、匯入的類型或行內介面/類型定義}` | {是/否}  | {若有}    | {必須清楚說明 prop 的用途和任何約束，例如：「必須是正整數。」}         |
- **內部狀態 (若有)：**
  { 描述元件管理的任何重要內部狀態。僅列出*並非*衍生自 props 或全域狀態的狀態。若狀態複雜，請考慮是否應改由自訂 hook 或全域狀態解決方案管理。 }
  | 狀態變數 | 類型      | 初始值 | 說明                                                                    |
  | :-------------- | :-------- | :------------ | :----------------------------------------------------------------------------- |
  | `isLoading`     | `boolean` | `false`       | 追蹤元件資料是否正在載入。                                   |
  | `{anotherState}`| `{type}`  | `{value}`     | {狀態變數及其用途的說明。}                               |
- **關鍵 UI 元素 / 結構：**
  { 提供一個類似偽 HTML 或 JSX 的結構來表示元件的 DOM。若適用，包含關鍵的條件式呈現邏輯。**此結構決定了 AI agent 的主要輸出。** }
  ```html
  <div> <!-- 主要卡片容器，具有特定類別，例如：根據 variant prop 的 styles.cardFull 或 styles.cardCompact -->
    <img src="{avatarUrl || defaultAvatar}" alt="使用者頭像" class="{styles.avatar}" />
    <h2>{userName}</h2>
    <p class="{variant === 'full' ? styles.emailFull : styles.emailCompact}">{userEmail}</p>
    {variant === 'full' && onEdit && <button onClick={onEdit} class="{styles.editButton}">編輯</button>}
  </div>
  ```
- **處理/發出的事件：**
  - **處理：** {例如：編輯按鈕上的 `onClick` (觸發 `onEdit` prop)。}
  - **發出：** {若元件發出 props 未涵蓋的自訂事件/回呼，請描述它們及其確切簽章。例如：`onFollow: (payload: { userId: string; followed: boolean }) => void`}
- **觸發的動作 (副作用)：**
  - **狀態管理：** {例如：「從 `src/store/slices/userSlice.ts` 分派 `userSlice.actions.setUserName(newName)`。Action payload 必須符合定義的 action creator。」或「從本機 `useReducer` hook 呼叫 `updateUserProfileOptimistic(newData)`。」}
  - **API 呼叫：** {指定呼叫「API 互動層」中的哪個服務/函式。例如：「在掛載時呼叫 `src/services/userService.ts` 中的 `userService.fetchUser(userId)`。請求 payload：`{ userId }`。成功回應會填入內部狀態 `userData`。錯誤回應會分派 `uiSlice.actions.showErrorToast({ message: '無法載入使用者詳細資料' })`。」}
- **樣式設定備註：**
  - {必須參考特定的 Design System 元件名稱 (例如：「使用 UI 函式庫中的 `<Button variant='primary'>`」) 或指定要套用的 Tailwind CSS 類別 / CSS module 類別名稱 (例如：「容器使用 `p-4 bg-white rounded-lg shadow-md`。標題使用 `text-xl font-semibold`。」) 或指定要套用的 SCSS 自訂元件類別 (例如：「容器使用 `@apply p-4 bg-white rounded-lg shadow-md`。標題使用 `@apply text-xl font-semibold`。」)。任何基於 props 或 state 的動態樣式設定邏輯都必須描述。若使用 Tailwind CSS，請列出主要的 utility 類別或用於自訂元件類別的 `@apply` 指令。AI Agent 應優先對簡單案例直接使用 utility 類別，並對複雜的樣式設定模式建議可重複使用的元件類別/React 元件。}
- **無障礙備註：**
  - {必須列出特定的 ARIA 屬性及其值 (例如：`aria-label="使用者個人資料卡"`、`role="article"`)、必要的鍵盤導覽行為 (例如：「Tab 鍵依序導覽至頭像、姓名、電子郵件，然後是編輯按鈕。編輯按鈕可聚焦並透過 Enter/Space 鍵啟動。」) 以及任何焦點管理需求 (例如：「若此元件開啟強制回應視窗，焦點必須被限制在內部。關閉強制回應視窗時，焦點返回觸發元素。」)。}

---

_對每個重要元件重複上述範本。_

---

## 深入狀態管理

{ 此區段擴展了狀態管理策略。**關於狀態管理解決方案的最終選擇，請參考主要架構文件。** }

- **選擇的解決方案：** {例如：Redux Toolkit、Zustand、Vuex、NgRx - 如主要架構文件所定義。}
- **狀態位置決策指南：**
    - **全域狀態 (例如：Redux/Zustand)：** 跨多個不相關元件共用的資料；跨路由持續存在的資料；透過 reducers/thunks 管理的複雜狀態邏輯。**必須用於 session 資料、使用者偏好設定、應用程式範圍的通知。**
    - **React Context API：** 主要在特定元件子樹中向下傳遞的狀態 (例如：主題、表單上下文)。與全域狀態相比，狀態較簡單，更新較少。**必須用於不適合 prop drilling 但也不需要全域使用的本地化狀態。**
    - **本機元件狀態 (`useState`、`useReducer`)：** UI 特定狀態，在元件或其直接子元件之外不需要 (例如：表單輸入值、下拉式選單開啟/關閉狀態)。**除非符合 Context 或全域狀態的標準，否則必須是預設選擇。**

### Store 結構 / Slices

{ 描述組織全域狀態的慣例 (例如：「每個需要全域狀態的主要功能都會有自己的 Redux slice，位於 `src/features/[featureName]/store.ts`」)。 }

- **核心 Slice 範例 (例如：`src/store/slices/sessionSlice.ts` 中的 `sessionSlice`)：**
  - **目的：** {管理使用者 session、驗證狀態以及可全域存取的基本使用者個人資料資訊。}
  - **狀態形狀 (介面/類型)：**
    ```typescript
    interface SessionState {
      currentUser: { id: string; name: string; email: string; roles: string[]; } | null;
      isAuthenticated: boolean;
      token: string | null;
      status: "idle" | "loading" | "succeeded" | "failed";
      error: string | null;
    }
    ```
  - **關鍵 Reducers/Actions (在 `createSlice` 內)：** {簡要列出主要的同步 actions，例如：`setCurrentUser`、`clearSession`、`setAuthStatus`、`setAuthError`。}
  - **Async Thunks (若有)：** {列出關鍵的 async thunks，例如：`loginUserThunk`、`fetchUserProfileThunk`。}
  - **Selectors (使用 `createSelector` 進行 memoized)：** {列出關鍵的 selectors，例如：`selectCurrentUser`、`selectIsAuthenticated`。}
- **Feature Slice 範本 (例如：`src/features/{featureName}/store.ts` 中的 `{featureName}Slice`)：**
  - **目的：** {當新功能需要自己的狀態 slice 時填寫。}
  - **狀態形狀 (介面/類型)：** {由功能定義。}
  - **關鍵 Reducers/Actions (在 `createSlice` 內)：** {由功能定義。}
  - **Async Thunks (若有，使用 `createAsyncThunk` 定義)：** {由功能定義。}
  - **Selectors (使用 `createSelector` 進行 memoized)：** {由功能定義。}
  - **匯出：** {所有 actions 和 selectors 都必須匯出。}

### 關鍵 Selectors

{ 列出任何核心、預先定義 slices 的重要 selectors。對於新興的 feature slices，selectors 將與 slice 一同定義。**所有衍生資料或組合多個狀態片段的 selectors 都必須使用 Reselect 的 `createSelector` (或其他狀態函式庫的等效功能) 進行 memoization。** }

- **`selectCurrentUser` (來自 `sessionSlice`)：** {傳回 `currentUser` 物件。}
- **`selectIsAuthenticated` (來自 `sessionSlice`)：** {傳回 `isAuthenticated` 布林值。}
- **`selectAuthToken` (來自 `sessionSlice`)：** {傳回 `sessionSlice` 中的 `token`。}

### 關鍵 Actions / Reducers / Thunks

{ 詳細說明核心、預先定義 slices 的更複雜 actions，尤其是非同步 thunks 或 sagas。每個 thunk 都必須清楚定義其目的、參數、進行的 API 呼叫 (參考 API 互動層)，以及如何在 pending、fulfilled 和 rejected 狀態下更新狀態。 }

- **核心 Action/Thunk 範例：`authenticateUser(credentials: AuthCredentials)` (在 `sessionSlice.ts` 中)：**
  - **目的：** {透過呼叫驗證 API 並更新 `sessionSlice` 來處理使用者登入。}
  - **參數：** `credentials: { email: string; password: string }`
  - **分派流程 (使用 Redux Toolkit `createAsyncThunk`)：**
    1. 在 `pending` 時：分派 `sessionSlice.actions.setAuthStatus('loading')`。
    2. 呼叫 `authService.login(credentials)` (來自 `src/services/authService.ts`)。
    3. 在 `fulfilled` (成功) 時：分派 `sessionSlice.actions.setCurrentUser(response.data.user)`、`sessionSlice.actions.setToken(response.data.token)`、`sessionSlice.actions.setAuthStatus('succeeded')`。
    4. 在 `rejected` (錯誤) 時：分派 `sessionSlice.actions.setAuthError(error.message)`、`sessionSlice.actions.setAuthStatus('failed')`。
- **Feature Action/Thunk 範本：`{featureActionName}` (在 `{featureName}Slice.ts` 中)：**
  - **目的：** {為特定功能的非同步操作填寫。}
  - **參數：** {定義具有類型的特定參數。}
  - **分派流程 (使用 `createAsyncThunk`)：** {由功能定義，遵循類似的 pending、fulfilled、rejected 狀態模式，包括 API 呼叫和狀態更新。}

## API 互動層

{ 描述前端如何與主要架構文件中定義的後端 API 通訊。 }

### Client/Service 結構

- **HTTP Client 設定：** {例如：`src/services/apiClient.ts` 中的 Axios 實例。**必須**包含：基礎 URL (來自環境變數 `NEXT_PUBLIC_API_URL` 或等效變數)、預設標頭 (例如：`Content-Type: 'application/json'`)、用於自動注入驗證 token (來自狀態管理，例如：`sessionSlice.token`) 和標準化錯誤處理/正規化 (見下文) 的攔截器。}
- **服務定義 (範例)：**
  - **`userService.ts` (在 `src/services/userService.ts` 中)：**
    - **目的：** {處理所有與使用者相關的 API 互動。}
    - **函式：** 每個服務函式都必須具有明確的參數類型、傳回類型 (例如：`Promise<User>`)、解釋目的、參數、傳回值以及任何特定錯誤處理的 JSDoc/TSDoc。它必須使用正確的端點、方法和 payload 呼叫已設定的 HTTP client (`apiClient`)。
      - `fetchUser(userId: string): Promise<User>`
      - `updateUserProfile(userId: string, data: UserProfileUpdateDto): Promise<User>`
  - **`productService.ts` (在 `src/services/productService.ts` 中)：**
    - **目的：** {...}
    - **函式：** {...}

### 錯誤處理與重試 (前端)

- **全域錯誤處理：** {API 錯誤如何被全域攔截？(例如：透過 `apiClient.ts` 中的 Axios 回應攔截器)。它們如何呈現/記錄？(例如：分派 `uiSlice.actions.showGlobalErrorBanner({ message: error.message })`，將詳細錯誤記錄到主控台/監控服務)。是否有全域錯誤狀態？(例如：`uiSlice.error`)。}
- **特定錯誤處理：** {元件可以針對更具上下文的回饋在本機處理特定的 API 錯誤 (例如：在表單欄位上顯示行內訊息：「無效的電子郵件地址」)。若偏離全域處理，則必須在元件的規格中記錄。}
- **重試邏輯：** {是否實作了用戶端重試邏輯 (例如：使用 `axios-retry` 搭配 `apiClient`)？若是，請指定設定：最大重試次數 (例如：3)、重試條件 (例如：網路錯誤、5xx 伺服器錯誤)、重試延遲 (例如：指數退避)。**必須僅適用於冪等請求 (GET、PUT、DELETE)。**}

## 路由策略

{ 詳細說明前端應用程式中如何處理導覽和路由。 }

- **路由函式庫：** {例如：React Router、Next.js App Router、Vue Router、Angular Router。根據主要架構文件。}

### 路由定義

{ 列出應用程式的主要路由以及為每個路由呈現的主要元件/頁面。 }

| 路徑模式           | 元件/頁面 (`src/app/...` 或 `src/pages/...`) | 保護                      | 備註                                                 |
| :--------------------- | :-------------------------------------------------- | :------------------------------ | :---------------------------------------------------- |
| `/`                    | `app/page.tsx` 或 `pages/HomePage.tsx`              | `Public`                        |                                                       |
| `/login`               | `app/login/page.tsx` 或 `pages/LoginPage.tsx`       | `Public` (若已驗證則重新導向)     | 若已驗證，則重新導向至 `/dashboard`。   |
| `/dashboard`           | `app/dashboard/page.tsx` 或 `pages/DashboardPage.tsx` | `Authenticated`                 |                                                       |
| `/products`            | `app/products/page.tsx`                             | `Public`                        |                                                       |
| `/products/:productId` | `app/products/[productId]/page.tsx`                 | `Public`                        | 參數：`productId` (string)                       |
| `/settings/profile`    | `app/settings/profile/page.tsx`                     | `Authenticated`, `Role:[USER]`  | 基於角色的保護範例。                   |
| `{anotherRoute}`       | `{ComponentPath}`                                   | `{Public/Authenticated/Role:[ROLE_NAME]}` | {備註、參數名稱與類型}                    |

### 路由守衛 / 保護

- **驗證守衛：** {描述如何根據驗證狀態保護路由。**指定確切的 HOC、hook、佈局或中介軟體機制及其位置** (例如：`src/guards/AuthGuard.tsx`，或 `middleware.ts` 中的 Next.js 中介軟體)。邏輯必須使用 `sessionSlice` (或等效) 中的驗證狀態。嘗試存取受保護路由的未驗證使用者必須重新導向至 `/login` (或指定的登入路徑)。}
- **授權守衛 (若適用)：** {描述如何根據使用者角色或權限保護路由。**指定確切的機制**，類似於驗證守衛。未經授權的使用者 (已驗證但缺乏權限) 必須顯示「禁止存取」頁面或重新導向至安全頁面。}

## 建置、打包與部署

{ 特定於前端建置和部署流程的詳細資料，補充主要架構文件中的「基礎架構與部署概觀」。 }

### 建置流程與腳本

- **關鍵建置腳本 (來自 `package.json`)：** {例如：`"build": "next build"`。它們的作用是什麼？指向 `package.json` 腳本。`"dev": "next dev"`、`"start": "next start"`。}。**AI Agent 不得產生寫死環境特定值的程式碼。所有此類值都必須透過定義的環境設定機制存取。**指定確切的檔案和存取方法。
- **環境設定管理：** {如何為不同環境 (dev、staging、prod) 管理 `process.env.NEXT_PUBLIC_API_URL` (或等效變數如 `import.meta.env.VITE_API_URL`)？(例如：Next.js/Vite 的 `.env`、`.env.development`、`.env.production` 檔案；透過 CI 變數在建置時注入)。指定確切的檔案和存取方法。}

### 關鍵打包最佳化

- **程式碼分割：** {如何實作/確保？(例如：「Next.js/Vite 會自動處理基於路由的程式碼分割。對於元件層級的程式碼分割，必須對非關鍵的大型元件/函式庫使用動態匯入 `React.lazy(() => import('./MyComponent'))` 或 `import('./heavy-module')`。」)}
- **Tree Shaking：** {如何實作/確保？(例如：「由現代建置工具如 Webpack/Rollup (Next.js/Vite 使用) 在使用 ES Modules 時確保。避免在共用函式庫中進行有副作用的匯入。」)}
- **延遲載入 (元件、圖片等)：** {延遲載入的策略。(例如：「元件：`React.lazy` 搭配 `Suspense`。圖片：使用特定於框架的圖片元件如 `next/image` (預設處理延遲載入)，或對標準 `<img>` 標籤使用 `loading='lazy'` 屬性。」)}
- **最小化與壓縮：** {由建置工具處理 (例如：Webpack/Terser、Vite/esbuild)？指定是否需要任何特定設定。壓縮 (例如：Gzip、Brotli) 通常由託管平台/CDN 處理。}

### 部署至 CDN/Hosting

- **目標平台：** {例如：Vercel、Netlify、AWS S3/CloudFront、Azure Static Web Apps。根據主要架構文件。}
- **部署觸發器：** {例如：透過 GitHub Actions 將 Git 推送至 `main` 分支 (參考主要 CI/CD pipeline)。}
- **資產快取策略：** {靜態資產如何快取？(例如：「不可變資產 (具有內容雜湊的 JS/CSS bundles) 具有 `Cache-Control: public, max-age=31536000, immutable`。HTML 檔案具有 `Cache-Control: no-cache` 或較短的 max-age (例如：`public, max-age=0, must-revalidate`) 以確保使用者取得最新的進入點。透過 {託管平台設定 / `next.config.js` 標頭 / CDN 規則} 設定。}

## 前端測試策略

{ 此區段詳細說明主要架構文件中的「測試策略」，著重於前端特定層面。**關於測試工具的最終選擇，請參考主要架構文件。** }

- **主要整體測試策略連結：** {參考主要的 `docs/architecture.md#overall-testing-strategy` 或等效文件。}

### 元件測試

- **範圍：** {在隔離環境中測試個別 UI 元件 (類似於元件的單元測試)。}
- **工具：** {例如：React Testing Library 搭配 Jest、Vitest、Vue Test Utils、Angular Testing Utilities。根據主要架構文件。}
- **重點：** {使用各種 props 呈現、使用者互動 (點擊、使用 `fireEvent` 或 `userEvent` 變更輸入)、事件發出、基本的內部狀態變更。**Snapshot testing 必須謹慎使用並有明確理由 (例如：用於非常穩定、純展示性且具有複雜 DOM 結構的元件)；偏好明確的斷言。**}
- **位置：** {例如：`*.test.tsx` 或 `*.spec.tsx` 與元件並存，或在 `__tests__` 子目錄中。}

### 功能/流程測試 (UI 整合)

- **範圍：** {測試多個元件如何互動以完成頁面內的小型使用者流程或功能，可能 mock API 呼叫或全域狀態管理。例如：測試功能內的完整表單提交，包括驗證和與 mocked service layer 的互動。}
- **工具：** {與元件測試相同 (例如：React Testing Library 搭配 Jest/Vitest)，但設定更複雜，涉及用於路由、狀態、API 呼叫的 mock providers。}
- **重點：** {元件之間的資料流程、基於互動的條件式呈現、功能內的導覽、與 mocked services/state 的整合。}

### 端對端 UI 測試工具與範圍

- **工具：** {重申主要測試策略中的工具，例如：Playwright、Cypress、Selenium。}
- **範圍 (前端重點)：** {定義 3-5 個必須由 E2E UI 測試從 UI 角度涵蓋的關鍵使用者旅程，例如：「使用者註冊和登入流程」、「將商品加入購物車並進入結帳頁面摘要」、「提交複雜的多步驟表單並驗證成功 UI 狀態和資料持久性 (透過 API mocks 或測試後端)。」}
- **UI 的測試資料管理：** {如何為 UI E2E 測試植入或 mock 一致的測試資料？(例如：API mocking layer 如 MSW、後端植入腳本、專用測試帳戶)。}

## 無障礙 (AX) 實作細節

{ 根據 UI/UX 規格中的 AX 需求，詳細說明這些需求將如何技術性地實作。 }

- **語義化 HTML：** {強調使用正確的 HTML5 元素。**AI Agent 必須優先使用語義化元素 (例如：`<nav>`、`<button>`、`<article>`)，而非在存在具有正確語義的原生元素時使用帶有 ARIA roles 的通用 `<div>`/`<span>`。**}
- **ARIA 實作：** {指定常見的自訂元件及其必要的 ARIA 模式 (例如：「自訂下拉式選單必須遵循 ARIA Combobox 模式，包括 `aria-expanded`、`aria-controls`、`role='combobox'` 等。自訂頁籤必須遵循 ARIA Tabbed Interface 模式。」)。連結至 ARIA Authoring Practices Guide (APG) 以供參考。}
- **鍵盤導覽：** {確保所有互動元素都可透過鍵盤聚焦和操作。焦點順序必須合乎邏輯。自訂元件必須根據 ARIA APG 實作鍵盤互動模式 (例如：用於選項群組/滑桿的箭頭鍵)。**}
- **焦點管理：** {在強制回應視窗、動態內容變更、路由轉換中如何管理焦點？(例如：「強制回應視窗必須限制焦點。開啟強制回應視窗時，焦點移至第一個可聚焦元素或強制回應視窗容器。關閉時，焦點返回觸發元素。路由變更應將焦點移至新頁面的主要內容區域或 H1。」)}
- **AX 測試工具：** {例如：Axe DevTools 瀏覽器擴充功能、Lighthouse 無障礙稽核。**自動化 Axe 掃描 (例如：對元件測試使用 `jest-axe`，或對 E2E 測試使用 Playwright/Cypress Axe 整合) 必須整合至 CI pipeline，並在發生新的 WCAG AA (或指定等級) 違規時使建置失敗。**手動測試程序：{列出關鍵的手動檢查，例如：所有互動元素的僅限鍵盤導覽、對關鍵使用者流程進行螢幕閱讀器測試 (例如：NVDA/JAWS/VoiceOver)。}}

## 效能考量

{ 強調前端特定的效能最佳化策略。 }

- **圖片最佳化：** {格式 (例如：WebP)、響應式圖片 (`<picture>`、`srcset`)、延遲載入。}
  - 實作要求：{例如：「所有圖片都必須使用 Next.js 的 `<Image>` 元件 (或等效的特定於框架的最佳化工具)。圖示使用 SVG。在支援的情況下偏好 WebP 格式。」}
- **程式碼分割與延遲載入 (若需要，重申建置區段的內容)：** {它如何影響感知效能。}
  - 實作要求：{例如：「Next.js 會自動處理基於路由的程式碼分割。必須對元件層級的延遲載入使用動態匯入 `import()`。」}
- **最小化重新呈現：** {像 `React.memo`、`shouldComponentUpdate`、最佳化 selectors 等技術。}
  - 實作要求：{例如：「對於經常以相同 props 呈現的元件，必須使用 `React.memo`。全域狀態的 Selectors 必須進行 memoized (例如：使用 Reselect)。避免在 render 方法中直接傳遞新的物件/陣列字面值或行內函式，以免造成不必要的重新呈現。」}
- **Debouncing/Throttling：** {用於搜尋輸入或視窗調整大小等事件處理常式。}
  - 實作要求：{例如：「對指定的事件處理常式使用像 `lodash.debounce` 或 `lodash.throttle` 這樣的工具程式。定義 debounce/throttle 等待時間。」}
- **虛擬化：** {用於長列表或大型資料集 (例如：React Virtualized、TanStack Virtual)。}
  - 實作要求：{例如：「若觀察到效能下降，則必須對任何呈現超過 {N，例如：100} 個項目的列表使用。」}
- **快取策略 (用戶端)：** {使用瀏覽器快取、用於 PWA 功能的 service workers (若適用)。}
  - 實作要求：{例如：「設定 service worker (若為 PWA) 以快取應用程式殼層和關鍵靜態資產。利用部署區段中定義的其他資產的 HTTP 快取標頭。」}
- **效能監控工具：** {例如：Lighthouse、WebPageTest、瀏覽器 DevTools 效能頁籤。指定哪些是主要的，以及 CI 中的任何自動化檢查。}

## 國際化 (i18n) 與本地化 (l10n) 策略

{此區段定義了在適用情況下支援多種語言和區域差異的策略。若不適用，請註明「目前此專案不需要國際化」。}

- **需求等級：** {例如：不需要、需要特定語言 [列出它們]、為未來擴充完全國際化。}
- **選擇的 i18n 函式庫/框架：** {例如：`react-i18next`、`vue-i18n`、`ngx-translate`、特定於框架的解決方案如 Next.js i18n 路由。指定確切的函式庫/機制。}
- **翻譯檔案結構與格式：** {例如：每個功能每個語言的 JSON 檔案 (`src/features/{featureName}/locales/{lang}.json`)，或全域檔案 (`public/locales/{lang}.json`)。定義確切的路徑和格式 (例如：扁平 JSON、巢狀 JSON)。}
- **翻譯鍵命名慣例：** {例如：`featureName.componentName.elementText`、`common.submitButton`。必須是清晰、一致且有文件記錄的模式。}
- **新增可翻譯字串的流程：** {例如：「AI Agent 必須將新的鍵新增至預設語言檔案 (例如：`en.json`)，並使用 i18n 函式庫的函式/元件 (例如：`<Trans>` 元件、`t()` 函式) 來呈現文字。不得在執行時期以阻止靜態分析的方式動態建構鍵。」}
- **處理複數：** {指定方法/語法，例如：透過所選函式庫使用 ICU 訊息格式 (例如：`t('key', { count: N })`)。}
- **日期、時間和數字格式化：** {指定 i18n 函式庫是否處理此問題，或是否應對每個地區設定使用其他函式庫 (例如：具有地區設定支援的 `date-fns-tz`、直接使用 `Intl` API) 和特定格式/樣式。}
- **預設語言：** {例如：`en-US`}
- **語言切換機制 (若適用)：** {使用者如何變更語言並使其持續存在？例如：「透過語言選擇器元件更新全域狀態/cookie，並可能更改 URL 路由。」}

## Feature Flag 管理

{此區段概述如何管理有條件啟用的功能。若不適用，請註明「目前此專案的主要架構考量不包含 feature flags」。}

- **需求等級：** {例如：不需要、用於特定推出、開發工作流程的核心部分。}
- **選擇的 Feature Flag 系統/函式庫：** {例如：LaunchDarkly、Unleash、Flagsmith、使用環境變數或設定服務的自訂解決方案。指定確切的工具/方法。}
- **在程式碼中存取 Flags：** {例如：「透過自訂 hook `useFeatureFlag('flag-name'): boolean` 或服務 `featureFlagService.isOn('flag-name')`。指定服務/provider 的確切介面、位置和初始化。」}
- **Flag 命名慣例：** {例如：`[SCOPE]_[FEATURE_NAME]_[TARGET_GROUP_OR_TYPE]`，例如：`CHECKOUT_NEW_PAYMENT_GATEWAY_ROLLOUT`、`USER_PROFILE_BETA_AVATAR_UPLOAD`。必須有文件記錄並一致應用。}
- **Flagged Features 的程式碼結構：** {例如：「使用條件式呈現 (`{isFeatureEnabled && <NewComponent />}`)。對於較大的功能，有條件地匯入元件 (`React.lazy` 搭配 flag 檢查) 或路由。避免在共用元件深處使用複雜的分支邏輯；偏好在較高層級設定 flag。」}
- **程式碼清理策略 (Flag 停用後)：** {例如：「一旦 flag 完全推出 (100% 使用者) 並被視為永久性，或完全移除，所有條件式邏輯、舊程式碼路徑以及 flag 本身都必須在 {N，例如：2} 個 sprints 內從程式碼庫中移除。這是一個強制性的技術債項目。」}
- **測試 Flagged Features：** {如何測試不同的 flag 變體？例如：「QA 團隊使用偵錯面板切換 flags。自動化 E2E 測試使用特定的 flag 設定執行。」}

## 前端安全性考量

{此區段強調強制性的前端特定安全性實務，補充主要架構文件。AI Agent 必須遵守這些準則。}

- **跨網站指令碼 (XSS) 防護：**
  - 框架依賴：{例如：「必須依賴 React 的 JSX 自動跳脫來呈現動態內容。除非內容經過明確清理，否則必須避免使用 Vue 的 `v-html`。」}
  - 明確清理：{若無法避免直接 DOM 操作 (強烈不建議)，請使用 {特定的清理函式庫/函式，如 DOMPurify}。指定其設定。}
  - 內容安全政策 (CSP)：{是否實作了 CSP？如何實作？例如：「CSP 透過後端/CDN 設定的 HTTP 標頭強制執行，如主要架構文件所定義。若不允許 `unsafe-inline`，前端可能需要確保對行內腳本使用 nonce。」若有，請連結至 CSP 定義。}
- **跨網站請求偽造 (CSRF) 防護 (若適用於基於 session 的驗證)：**
  - 機制：{例如：「後端使用 synchronizer token 模式。若非由 HTTP client 或表單自動處理，前端確保 token 包含在會改變狀態的請求中。」關於後端詳細資料，請參考主要架構文件。}
- **安全 Token 儲存與處理 (用於用戶端 tokens 如 JWT)：**
  - 儲存機制：{**必須指定確切機制**：例如：透過狀態管理儲存在記憶體中 (例如：Redux/Zustand store，關閉頁籤時清除)、`HttpOnly` cookies (若由後端設定且前端不需要讀取它們)、`sessionStorage`。**強烈不建議對 token 儲存使用 `localStorage`。**}
  - Token 更新：{描述用戶端參與，例如：「`apiClient.ts` 中的攔截器處理 401 錯誤以觸發 token 更新端點。」}
- **第三方腳本安全性：**
  - 政策：{例如：「所有第三方腳本 (分析、廣告、小工具) 都必須經過必要性和安全性審查。非同步載入腳本 (`async/defer`)。」}
  - 子資源完整性 (SRI)：{例如：「對於從 CDN 載入的所有外部腳本和樣式表，若資源穩定，則必須使用 SRI 雜湊。」}
- **用戶端資料驗證：**
  - 目的：{例如：「用戶端驗證僅用於改善 UX (即時回饋)。**所有關鍵資料驗證都必須在伺服器端進行** (如主要架構文件所定義)。」}
  - 實作：{例如：「對表單驗證使用 {form_library_name 如 Formik/React Hook Form}。規則應在適當時鏡像伺服器端驗證。」}
- **防止點擊劫持：**
  - 機制：{例如：「主要防禦是 `X-Frame-Options` 或 `frame-ancestors` CSP 指令，由後端/CDN 設定。前端程式碼不應依賴 frame-busting 腳本。」}
- **API 金鑰洩漏 (用於用戶端取用的服務)：**
  - 限制：{例如：「用於 Google Maps (用戶端 JS SDK) 等服務的 API 金鑰必須透過服務供應商的主控台進行限制 (例如：HTTP referrer、IP 位址、API 限制)。」}
  - 後端代理：{例如：「對於需要更高保密性或涉及敏感操作的金鑰，必須建立後端代理端點；前端呼叫代理，而非直接呼叫第三方服務。」}
- **安全通訊 (HTTPS)：**
  - 要求：{例如：「與後端 API 的所有通訊都必須使用 HTTPS。禁止混合內容 (HTTPS 頁面上的 HTTP 資產)。」}
- **依賴項漏洞：**
  - 流程：{例如：「在 CI 中執行 `npm audit --audit-level=high` (或等效指令)。高/嚴重漏洞必須在部署前解決。監控 Dependabot/Snyk alerts。」}

## 瀏覽器支援與漸進式增強

{此區段定義目標瀏覽器以及應用程式在功能較弱或非標準環境中的行為方式。}

- **目標瀏覽器：** {例如：「Chrome、Firefox、Safari、Edge 的最新 2 個穩定版本。若專案限制有要求，可列出特定版本。不支援任何版本的 Internet Explorer。」必須明確。}
- **Polyfill 策略：**
  - 機制：{例如：「在應用程式進入點匯入 `core-js@3`。Babel `preset-env` 設定了上述瀏覽器目標以包含必要的 polyfills。」}
  - 特定 Polyfills (若 `core-js` 之外還有其他)：{列出特定功能所需的任何其他 polyfills，例如：`smoothscroll-polyfill`。}
- **JavaScript 需求與漸進式增強：**
  - 基準：{例如：「核心應用程式功能需要在瀏覽器中啟用 JavaScript。」或「關鍵內容 (例如：文章、產品資訊) 和主要導覽必須在沒有 JavaScript 的情況下可存取和閱讀。互動功能和增強功能透過 JavaScript 疊加在頂層 (漸進式增強方法)。」指定所選方法。}
  - 無 JS 體驗 (若為漸進式增強)：{描述在沒有 JS 的情況下哪些功能可用。例如：「使用者可以檢視頁面和導覽。表單可能無法提交或將使用標準 HTML 提交。」}
- **CSS 相容性與備援：**
  - 工具：{例如：「使用設定了目標瀏覽器列表的 Autoprefixer (透過 PostCSS) 新增供應商前綴。」}
  - 功能使用：{例如：「避免使用目標瀏覽器支援率低於 90% 的 CSS 功能，除非明確定義並測試了優雅降級或備援 (例如：使用 `@supports` 查詢)。」}
- **無障礙備援：** {考量若支援矩陣中較舊的輔助技術不支援某些 ARIA 版本或進階無障礙功能時，功能的行為方式。}

## 變更記錄

| 變更 | 日期 | 版本 | 說明 | 作者 |
| ------ | ---- | ------- | ----------- | ------ |

==================== END: front-end-architecture-tmpl ====================


==================== START: front-end-spec-tmpl ====================
# {專案名稱} UI/UX 規格

## 簡介

{說明目的 - 定義專案使用者介面的使用者體驗目標、資訊架構、使用者流程和視覺設計規格。}

- **主要設計檔案連結：** {例如：Figma、Sketch、Adobe XD URL}
- **已部署的 Storybook / Design System 連結：** {URL，若適用}

## 整體 UX 目標與原則

- **目標使用者畫像：** {參考畫像或簡要描述關鍵使用者類型及其目標。}
- **可用性目標：** {例如：易學性、使用效率、錯誤預防。}
- **設計原則：** {列出 3-5 個指導 UI/UX 設計的核心原則 - 例如：「清晰勝於巧妙」、「一致性」、「提供回饋」。}

## 資訊架構 (IA)

- **網站地圖 / 畫面清單：**
  ```mermaid
  graph TD
      A[首頁] --> B(儀表板);
      A --> C{設定};
      B --> D[檢視詳細資料];
      C --> E[個人資料設定];
      C --> F[通知設定];
  ```
  _(或提供所有畫面/頁面的列表)_
- **導覽結構：** {描述主要導覽 (例如：頂端列、側邊欄)、次要導覽、麵包屑等。}

## 使用者流程

{詳細說明關鍵使用者任務。使用圖表或說明。}

### {使用者流程名稱，例如：使用者登入}

- **目標：** {使用者想要達成的目標。}
- **步驟 / 圖表：**
  ```mermaid
  graph TD
      Start --> EnterCredentials[輸入電子郵件/密碼];
      EnterCredentials --> ClickLogin[點擊登入按鈕];
      ClickLogin --> CheckAuth{驗證成功？};
      CheckAuth -- 是 --> Dashboard;
      CheckAuth -- 否 --> ShowError[顯示錯誤訊息];
      ShowError --> EnterCredentials;
  ```
  _(或：連結至 Figma/Miro 中的特定流程圖)_

### {另一個使用者流程名稱}

{...}

## 線框稿與模型

{參考上述主要設計檔案連結。可選擇嵌入關鍵模型或描述主要畫面佈局。}

- **畫面 / 檢視名稱 1：** {佈局和關鍵元素的說明。連結至特定的 Figma frame/頁面。}
- **畫面 / 檢視名稱 2：** {...}

## 元件函式庫 / Design System 參考

## 品牌與風格指南參考

{連結至主要來源或在此處定義關鍵元素。}

- **調色盤：** {主要、次要、強調、回饋顏色 (十六進位碼)。}
- **排版：** {標題、內文等的字型家族、大小、粗細。}
- **圖示：** {圖示集連結、使用說明。}
- **間距與網格：** {定義邊界、內距、網格系統規則。}

## 無障礙 (AX) 需求

- **目標合規性：** {例如：WCAG 2.1 AA}
- **特定需求：** {複雜元件的鍵盤導覽模式、ARIA landmarks/屬性、色彩對比度最小值。}

## 響應式設計

- **中斷點：** {定義行動裝置、平板電腦、桌上型電腦等的像素值。}
- **適應策略：** {描述佈局和元件如何在不同中斷點之間適應。參考設計。}

## 變更記錄

| 變更        | 日期       | 版本 | 說明         | 作者         |
| ------------- | ---------- | ------- | ------------------- | -------------- |

==================== END: front-end-spec-tmpl ====================


==================== START: prd-tmpl ====================
# {專案名稱} 產品需求文件 (PRD)

## 目標、目的與背景

這部分應主要來自使用者或提供的簡報，但視需要請求澄清。

## 功能需求 (MVP)

此時您應有大致概念，但請澄清、建議問題並解釋以確保正確無誤。

## 非功能需求 (MVP)

此時您應有大致概念，但請澄清、建議問題並解釋以確保正確無誤。

## 使用者互動與設計目標

{
若產品包含使用者介面 (UI)，此區段將擷取產品經理對使用者體驗 (UX) 的高階願景和目標。此資訊將作為設計架構師的重要起點和簡報。

考量並從使用者處獲取以下資訊：

- **整體願景與體驗：** 期望的外觀與風格為何 (例如：「現代簡約」、「友善親切」、「資料密集且專業」)？使用者應有何種體驗？
- **關鍵互動模式：** 使用者與核心功能的互動是否有特定方式 (例如：「X 的拖放介面」、「Y 的精靈式設定」、「Z 的即時儀表板」)？
- **核心畫面/檢視 (概念性)：** 從產品角度來看，哪些是最關鍵的畫面或檢視，以實現 MVP 的價值？(例如：「登入畫面」、「主儀表板」、「項目詳細資料頁面」、「設定頁面」)。
- **無障礙期望：** 是否有已知的高階無障礙目標 (例如：「必須可供螢幕閱讀器使用者使用」)。
- **品牌考量 (高階)：** 是否有任何已知的品牌元素或風格指南必須納入？
- **目標裝置/平台：** (例如：「主要為網頁桌上型電腦」、「行動優先的響應式網頁應用程式」)。

此區段並非旨在成為詳細的 UI 規格，而是作為產品導向的簡報，以指導後續由設計架構師進行的詳細工作，設計架構師將建立全面的 UI/UX 規格文件。
}

## 技術假設

此處可列出主要供架構師產生技術細節的資訊。這可以是我們已知或從使用者處獲得的任何高階技術資訊。向使用者詢問以獲得關於語言、框架、入門範本知識、函式庫、外部 API、潛在函式庫選擇等的基本概念。

- **Repository 與服務架構：** {關鍵決策：記錄所選的 repository 結構 (例如：Monorepo、Polyrepo) 和高階服務架構 (例如：Monolith、Microservices、Monorepo 內的 Serverless functions)。根據專案目標、MVP 範圍、團隊結構和可擴展性需求解釋理由。此決策直接影響技術方法並通知 Architect Agent。}

### 測試需求

除了單元測試外，我們將如何驗證功能？我們是否需要手動腳本或測試、e2e、整合測試等... 從使用者處了解以填寫此區段。

## Epic 概觀

- **Epic {#}：{標題}**
  - 目標：{簡潔的 1-2 句話，描述此 Epic 的主要目的和價值。}
  - Story {#}：身為 {使用者/系統類型}，我想要 {執行一個動作 / 達成一個目標} 以便於 {我能實現一個益處 / 達成一個理由}。
    - {驗收標準列表}
  - Story {#}：身為 {使用者/系統類型}，我想要 {執行一個動作 / 達成一個目標} 以便於 {我能實現一個益處 / 達成一個理由}。
    - {驗收標準列表}
- **Epic {#}：{標題}**
  - 目標：{簡潔的 1-2 句話，描述此 Epic 的主要目的和價值。}
  - Story {#}：身為 {使用者/系統類型}，我想要 {執行一個動作 / 達成一個目標} 以便於 {我能實現一個益處 / 達成一個理由}。
    - {驗收標準列表}
  - Story {#}：身為 {使用者/系統類型}，我想要 {執行一個動作 / 達成一個目標} 以便於 {我能實現一個益處 / 達成一個理由}。
    - {驗收標準列表}

## 關鍵參考文件

{ 此區段稍後將根據先前區段分割成較小文件後建立 }

## MVP 後超出範圍的想法

您和使用者同意超出範圍或可從範圍中移除以保持 MVP 精簡的任何內容。考量 PRD 的目標，以及哪些可能是額外的鍍金或可在 MVP 完成並交付以評估功能和市場契合度或使用情況後再進行的附加功能。

## [選用：僅適用於簡化 PM 至開發工作流程] 核心技術決策與應用程式結構

{僅當 PM 在「簡化 PM 至開發工作流程」中操作時才填寫此區段。它擷取了通常由 Architect 定義的基本技術基礎，從而實現更直接的開發路徑。此資訊應在初步 PRD 區段 (目標、使用者等) 草擬後，理想情況下在詳細的 Epic/Story 定義之前或同時收集，並視需要更新。}

### 技術堆疊選型

{協同定義核心技術。在適當時具體說明選擇和版本。}

- **主要後端語言/框架：** {例如：Python/FastAPI、Node.js/Express、Java/Spring Boot}
- **主要前端語言/框架 (若適用)：** {例如：TypeScript/React (Next.js)、JavaScript/Vue.js}
- **資料庫：** {例如：PostgreSQL、MongoDB、AWS DynamoDB}
- **關鍵函式庫/服務 (後端)：** {例如：驗證 (JWT、OAuth provider)、ORM (SQLAlchemy)、快取 (Redis)}
- **關鍵函式庫/服務 (前端，若適用)：** {例如：UI 元件函式庫 (Material-UI、Tailwind CSS + Headless UI)、狀態管理 (Redux、Zustand)}
- **部署平台/環境：** {例如：Docker on AWS ECS、Vercel、Netlify、Kubernetes}
- **版本控制系統：** {例如：Git 搭配 GitHub/GitLab}

### 建議的應用程式結構

{描述程式碼庫的高階組織。這可能包括簡單的基於文字的目錄佈局、主要模組/元件列表以及它們如何互動的簡要說明。目標是為開發者提供清晰的起點。}

範例：

```
/
├── app/                  # 主要應用程式原始碼
│   ├── api/              # 後端 API 路由與邏輯
│   │   ├── v1/
│   │   └── models.py
│   ├── web/              # 前端元件與頁面 (若為 monolithic)
│   │   ├── components/
│   │   └── pages/
│   ├── core/             # 共用商業邏輯、工具程式
│   └── main.py           # 應用程式進入點
├── tests/                # 單元與整合測試
├── scripts/              # 工具腳本
├── Dockerfile
├── requirements.txt
└── README.md
```

- **Monorepo/Polyrepo：** {指定是否設想 monorepo 或 polyrepo 結構，並簡述原因。}
- **關鍵模組/元件與職責：**
  - {模組 1 名稱}：{其目的與關鍵職責的簡要說明}
  - {模組 2 名稱}：{其目的與關鍵職責的簡要說明}
  - ...
- **資料流程概觀 (概念性)：** {簡要描述資料預期如何在主要元件之間流動，例如：前端 -> API -> 核心邏輯 -> 資料庫。}

## 變更記錄

| 變更 | 日期 | 版本 | 說明 | 作者 |
| ------ | ---- | ------- | ----------- | ------ |

----- END PRD START CHECKLIST OUTPUT ------

## 檢查清單結果報告

----- END Checklist START Design Architect `UI/UX Specification Mode` Prompt ------

----- END Design Architect `UI/UX Specification Mode` Prompt START Architect Prompt ------

## 初始 Architect 提示

根據我們對 {產品名稱} 的討論和需求分析，我已彙編以下技術指南，以供您在架構分析和決策時參考，從而啟動架構建立模式：

### 技術基礎架構

- **Repository 與服務架構決策：** {重申在「技術假設」中做出的決策，例如：Monorepo，其中 Next.js 前端和 Python FastAPI 後端服務位於同一 repo 中；或 Polyrepo，其中包含獨立的前端 (Next.js) 和後端 (Spring Boot Microservices) repositories。}
- **入門專案/範本：** {關於應使用的任何入門專案、範本或現有程式碼庫的資訊}
- **託管/雲端供應商：** {指定的雲端平台 (AWS、Azure、GCP 等) 或託管需求}
- **前端平台：** {框架/函式庫偏好或需求 (React、Angular、Vue 等)}
- **後端平台：** {框架/語言偏好或需求 (Node.js、Python/Django 等)}
- **資料庫需求：** {關聯式、NoSQL、偏好的特定產品或服務}

### 技術限制

- {列出任何影響架構決策的技術限制}
- {包含任何強制性的技術、服務或平台}
- {注意任何具有特定技術影響的整合需求}

### 部署考量

- {部署頻率期望}
- {CI/CD 需求}
- {環境需求 (本機、開發、預備、生產)}

### 本機開發與測試需求

{僅當使用者表示這些功能很重要時才包含此區段。若根據使用者偏好不適用，您可以移除此區段。}

- {本機開發環境需求}
- {對命令列測試功能的期望}
- {跨不同環境測試的需求}
- {應提供的工具腳本或工具}
- {元件的任何特定可測試性需求}

### 其他技術考量

- {具有技術影響的安全性需求}
- {具有架構影響的可擴展性需求}
- {Architect 應考量的任何其他技術背景}

----- END Architect Prompt -----

==================== END: prd-tmpl ====================


==================== START: project-brief-tmpl ====================
# 專案簡報：{專案名稱}

## 簡介 / 問題陳述

{描述核心概念、正在解決的問題或正在處理的機會。為何需要此專案？}

## 願景與目標

- **願景：** {描述此專案期望的高階未來狀態或影響。}
- **主要目標：** {列出 2-5 個針對最小可行產品 (MVP) 的具體、可衡量、可達成、相關且有時限 (SMART) 的目標。}
  - 目標 1：...
  - 目標 2：...
- **成功指標 (初步想法)：** {我們將如何衡量專案/MVP 是否成功？列出潛在的 KPI。}

## 目標受眾 / 使用者

{描述此產品/系統的主要使用者。他們是誰？他們與此專案相關的關鍵特徵或需求是什麼？}

## 關鍵功能 / 範圍 (MVP 的高階想法)

{列出為 MVP 設想的核心功能。保持高階；詳細資料將記錄在 PRD/Epics 中。}

- 功能想法 1：...
- 功能想法 2：...
- 功能想法 N：...

## MVP 後功能 / 範圍與想法

{列出設想為 MVP 後潛在的核心功能。保持高階；詳細資料將記錄在 PRD/Epics/架構中。}

- 功能想法 1：...
- 功能想法 2：...
- 功能想法 N：...

## 已知技術限制或偏好

- **限制：** {列出任何已知的限制以及技術要求或偏好 - 例如：預算、時程、特定技術要求、必要的整合、合規需求。}
- **初步架構偏好 (若有)：** {擷取關於 repository 結構 (例如：monorepo、polyrepo) 和整體服務架構 (例如：monolith、microservices、serverless components) 的任何初步想法或強烈偏好。這並非最終決策點，僅供初步了解。}
- **風險：** {識別潛在風險 - 例如：技術挑戰、資源可用性、市場接受度、依賴項。}
- **使用者偏好：** {使用者提出的任何非高階功能的特定要求，這些要求可能影響技術或函式庫選擇，或在腦力激盪或草擬 PRD 過程中出現但未包含在先前文件區段中的任何其他事項}

## 相關研究 (選用)

{連結至或總結任何已進行的初步研究結果 (例如：`deep-research-report-BA.md`)。}

## PM 提示

此專案簡報提供了 {專案名稱} 的完整背景。請從「PRD 產生模式」開始，徹底檢閱簡報，與使用者合作逐段建立 PRD，並根據您的模式 1 程式設計能力，請求任何必要的澄清或建議改進。

<example_handoff_prompt>
此專案簡報提供了 Mealmate 的完整背景。請從「PRD 產生模式」開始，徹底檢閱簡報，與使用者合作逐段建立 PRD，並根據您的模式 1 程式設計能力，請求任何必要的澄清或建議改進。</example_handoff_prompt>

==================== END: project-brief-tmpl ====================


==================== START: story-tmpl ====================
# Story {EpicNum}.{StoryNum}：{從 Epic 檔案複製的簡短標題}

## 狀態：{ Draft | Approved | InProgress | Done }

## Story

- 身為 [角色]
- 我想要 [動作]
- 以便於 [益處]

## 驗收標準 (ACs)

{ 複製驗收標準編號列表 }

## 任務 / 子任務

- [ ] 任務 1 (AC：# 若適用)
  - [ ] 子任務1.1...
- [ ] 任務 2 (AC：# 若適用)
  - [ ] 子任務 2.1...
- [ ] 任務 3 (AC：# 若適用)
  - [ ] 子任務 3.1...

## 開發技術指南 {任務/子任務未涵蓋的詳細資料}

## Story 進度備註

### 使用的 Agent 模型：`<Agent 模型名稱/版本>`

### 完成備註列表
{關於實作選擇、困難或需要後續追蹤的任何備註}

### 變更記錄

==================== END: story-tmpl ====================

