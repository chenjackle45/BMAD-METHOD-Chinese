# {專案名稱} 架構文件

## 前言／序言

{本文件概述了整體專案架構，包括後端系統、共享服務以及非 UI 特定問題。其主要目標是作為 AI 驅動開發的指導性架構藍圖，確保一致性並遵循所選的模式和技術。

**與前端架構的關係：**
如果專案包含重要的使用者介面，則一份獨立的前端架構文件（通常命名為 `front-end-architecture-tmpl.txt` 或類似名稱，並在「關鍵參考文件」部分連結）將詳細說明前端特定的設計，並且必須與本文件結合使用。本文件中記錄的核心技術堆疊選擇（請參閱「最終技術堆疊選擇」）對整個專案（包括任何前端組件）具有決定性意義。}

## 目錄

{ 如果新增或刪除章節，請更新此處 }

## 技術摘要

{ 提供一段簡短的概述，說明系統的架構、關鍵組件、技術選擇以及使用的架構模式。請參考 PRD 中的目標。 }

## 高階概觀

{ 描述主要的架構風格（例如，Monolith、Microservices、Serverless、Event-Driven），反映 PRD 中所做的決定。解釋儲存庫結構（Monorepo/Polyrepo）。在概念層級上解釋主要的使用者互動或資料流程。 }

{ 在此處插入高階 Mermaid 系統情境或互動圖 - 例如，Mermaid Class C4 模型第 1 層和第 2 層 }

## 採用的架構／設計模式

{ 列出為架構選擇的關鍵高階模式。這些基礎模式應儘早建立，因為它們指導組件設計、互動和技術選擇。 }

- **模式 1：** {例如，Serverless、Event-Driven、Microservices、CQRS} - _理由／參考：_ {簡述原因，或視需要連結至更詳細的說明}
- **模式 2：** {例如，Dependency Injection、Repository Pattern、Module Pattern} - _理由／參考：_ {...}
- **模式 N：** {...}

## 組件視圖

{ 描述系統的主要邏輯組件或服務及其職責，反映已決定的整體架構（例如，不同的微服務、monolith 中的模組、monorepo 中的套件）以及採用的架構模式。解釋它們如何協作。 }

- 組件 A：{職責說明}

{ 如果有幫助，在此處插入組件圖 - 例如，使用 Mermaid graph TD 或 C4 模型容器／組件圖 }

- 組件 N...：{職責說明}

{ 如果有幫助，在此處插入組件圖 - 例如，使用 Mermaid graph TD 或 C4 模型容器／組件圖 }

## 專案結構

{ 提供一個 ASCII 或 Mermaid 圖表來表示專案的資料夾結構。以下是一個通用範例。如果正在使用 `front-end-architecture-tmpl.txt`（或等效文件），它將包含前端部分的詳細結構（例如，在 `src/frontend/` 內或專用的 `frontend/` 根目錄中）。共享程式碼結構（例如，在 monorepo 的 `packages/` 目錄中）也應在此處詳細說明。}

```plaintext
{project-root}/
├── .github/                    # CI/CD 工作流程 (例如，GitHub Actions)
│   └── workflows/
│       └── main.yml
├── .vscode/                    # VSCode 設定 (選用)
│   └── settings.json
├── build/                      # 編譯輸出 (若適用，通常會被 git-ignore)
├── config/                     # 靜態設定檔 (若有)
├── docs/                       # 專案文件 (PRD、架構文件等)
│   ├── index.md
│   └── ... (其他 .md 檔案)
├── infra/                      # 基礎設施即程式碼 (例如，CDK、Terraform)
│   └── lib/
│   └── bin/
├── node_modules/ / venv / target/ # 專案依賴項 (git-ignored)
├── scripts/                    # 工具腳本 (建置、部署輔助程式等)
├── src/                        # 應用程式原始碼
│   ├── backend/                # 後端特定應用程式碼 (如果存在不同的前端)
│   │   ├── core/               # 核心業務邏輯、領域模型
│   │   ├── services/           # 業務服務、協調器
│   │   ├── adapters/           # 對外部系統 (資料庫、API) 的適配器
│   │   ├── controllers/ / routes/ # API 端點處理常式
│   │   └── main.ts / app.py    # 後端應用程式進入點
│   ├── frontend/               # 預留位置：如果使用，請參閱前端架構文件以獲取詳細資訊
│   ├── shared/ / common/       # 共享程式碼 (例如，類型、工具程式、領域模型 (若適用))
│   │   └── types/
│   └── main.ts / index.ts / app.ts # 主要應用程式進入點 (如果不使用上述的後端/前端分離)
├── stories/                    # 為開發產生的 story 檔案 (選用)
│   └── epic1/
├── test/                       # 自動化測試
│   ├── unit/                   # 單元測試 (對應 src 結構)
│   ├── integration/            # 整合測試
│   └── e2e/                    # 端對端測試
├── .env.example                # 環境變數範例
├── .gitignore                  # Git 忽略規則
├── package.json / requirements.txt / pom.xml # 專案清單與依賴項
├── tsconfig.json / pyproject.toml # 特定語言設定 (若適用)
├── Dockerfile                  # Docker 建置說明 (若適用)
└── README.md                   # 專案概觀與設定說明
```

(根據實際專案類型調整範例樹 - 例如，Python 會有 requirements.txt 等。上述結構說明了具有不同前端的專案的潛在分離方式；對於較簡單的專案或 API，`src/` 結構可能會更扁平。)

### 主要目錄說明

- docs/: 包含所有專案規劃和參考文件。
- infra/: 存放基礎設施即程式碼的定義 (例如，AWS CDK、Terraform)。
- src/: 包含主要應用程式原始碼。可根據專案複雜度和是否使用獨立的前端架構文件進行細分 (例如，`backend/`、`frontend/`、`shared/`)。
- src/backend/core/ / src/core/ / src/domain/: 核心業務邏輯、實體、使用案例，獨立於框架/外部服務。
- src/backend/adapters/ / src/adapters/ / src/infrastructure/: 實作細節、與資料庫、雲端 SDK、框架的互動。
- src/backend/controllers/ / src/routes/ / src/pages/: API 請求或 UI 視圖的進入點 (如果 UI 簡單且未在獨立的前端結構中)。
- test/: 包含所有自動化測試，在適用情況下對應 src/ 結構。

### 注意事項

{提及任何特定的建置輸出路徑、編譯器設定指標或其他相關的結構注意事項。}

## API 參考

### 使用的外部 API

{系統互動的每個外部 API 都重複此部分。}

#### {外部服務名稱} API

- **目的：** {系統為何使用此 API？}
- **基礎 URL：**
  - 生產環境：`{URL}`
  - 預備/開發環境：`{URL}`
- **驗證：** {描述方法 - 例如，標頭中的 API 金鑰 (標頭名稱：`X-API-Key`)、OAuth 2.0 用戶端憑證、基本驗證。金鑰名稱請參考 `docs/environment-vars.md`。}
- **使用的主要端點：**
  - **`{HTTP 方法} {/path/to/endpoint}`:**
    - 說明：{此端點的作用是什麼？}
    - 請求參數：{查詢參數、路徑參數}
    - 請求主體結構描述：{內嵌提供 JSON 結構描述，或僅在結構描述非常龐大或複雜時連結至 `docs/data-models.md` 中的詳細定義。}
    - 請求範例：`{程式碼區塊}`
    - 成功回應結構描述 (代碼：`200 OK`)：{內嵌提供 JSON 結構描述，或僅在非常複雜時連結至 `docs/data-models.md` 中的詳細定義。}
    - 錯誤回應結構描述 (代碼：`4xx`、`5xx`)：{內嵌提供 JSON 結構描述，或僅在非常複雜時連結至 `docs/data-models.md` 中的詳細定義。}
    - 回應範例：`{程式碼區塊}`
  - **`{HTTP 方法} {/another/endpoint}`:** {...}
- **速率限制：** {如果已知}
- **官方文件連結：** {URL}

### 提供的內部 API (若適用)

{如果系統公開自己的 API (例如，在微服務架構中或 для UI 前端)。每個 API 重複此部分。}

#### {內部 API / 服務名稱} API

- **目的：** {此 API 提供什麼服務？}
- **基礎 URL：** {例如，`/api/v1/...`}
- **驗證/授權：** {描述如何控制存取。}
- **端點：**
  - **`{HTTP 方法} {/path/to/endpoint}`:**
    - 說明：{此端點的作用是什麼？}
    - 請求參數：{...}
    - 請求主體結構描述：{內嵌提供 JSON 結構描述，或僅在非常複雜時連結至 `docs/data-models.md` 中的詳細定義。}
    - 成功回應結構描述 (代碼：`200 OK`)：{內嵌提供 JSON 結構描述，或僅在非常複雜時連結至 `docs/data-models.md` 中的詳細定義。}
    - 錯誤回應結構描述 (代碼：`4xx`、`5xx`)：{內嵌提供 JSON 結構描述，或僅在非常複雜時連結至 `docs/data-models.md` 中的詳細定義。}
  - **`{HTTP 方法} {/another/endpoint}`:** {...}

## 資料模型

### 核心應用程式實體／領域物件

{定義應用程式使用的主要物件/概念。每個主要實體重複此小節。}

#### {實體名稱，例如：使用者、訂單、產品}

- **說明：** {此實體代表什麼？}
- **結構描述／介面定義：**
  ```typescript
  // 使用 TypeScript 介面的範例
  export interface {EntityName} {
    id: string; // {說明，例如：唯一識別碼}
    propertyName: string; // {說明}
    optionalProperty?: number; // {說明}
    // ... 其他屬性
  }
  ```
- **驗證規則：** {列出基本類型以外的任何特定驗證規則 - 例如，最大長度、格式、範圍。}

### API 酬載結構描述 (若不同)

{僅當結構描述與核心實體不同且未在 API 參考部分的 API 端點定義下完整詳細說明時，才在此處定義結構描述。盡可能直接在其 API 中詳細說明請求/回應結構描述。本節適用於可能在多個內部 API 中使用或與核心持久化實體顯著不同的複雜、可重複使用的酬載結構。}

#### {API 端點／目的，例如：建立訂單請求，視需要重複此部分}

- **結構描述／介面定義：**
  ```typescript
  // 範例
  export interface CreateOrderRequest {
    customerId: string;
    items: { productId: string; quantity: number }[];
    // ...
  }
  ```

### 資料庫結構描述 (若適用)

{如果使用資料庫，請定義資料表結構或文件資料庫結構描述。視需要重複}

#### {資料表／集合名稱}

- **目的：** {此資料表儲存什麼資料？}
- **結構描述定義：**
  ```sql
  -- SQL 範例
  CREATE TABLE {TableName} (
    id VARCHAR(36) PRIMARY KEY,
    column_name VARCHAR(255) NOT NULL,
    numeric_column DECIMAL(10, 2),
    -- ... 其他欄位、索引、約束
  );
  ```
  _(或者，使用 ORM 模型定義、NoSQL 文件結構等)_

## 核心工作流程／循序圖

{ 使用 Mermaid 循序圖說明關鍵或複雜的工作流程。可以有將整個專案聯繫起來的高階圖，也可以有較小的 epic 層級循序圖。 }

## 最終技術堆疊選擇

{ 本節概述專案的最終技術選擇。這些選擇應在透徹了解專案需求、組件、資料模型和核心工作流程後進行。Architect Agent 應引導使用者完成這些決策，確保每個選擇都有合理的理由並準確記錄在下表中。

此表是所有技術選擇的**唯一真實來源**。其他架構文件（例如，前端架構）必須參考這些選擇並詳細說明其特定應用，而不是重新定義它們。

此處需要討論和最終確定的關鍵決策（稍後將在下面的詳細堆疊表中擴展並正式記錄）包括以下考量：

- 偏好的前端入門範本：{ 範本或入門套件的 URL，若有使用 }
- 偏好的後端入門範本：{ 範本或入門套件的 URL，若有使用 }
- 主要語言與版本：{例如，TypeScript 5.x、Python 3.11 - 指定確切版本，例如 `5.2.3`}
- 主要執行環境與版本：{例如，Node.js 22.x - 指定確切版本，例如 `22.0.1`}

必須是明確的選擇；不要列出開放式選項（例如，對於網頁抓取，選擇一個工具，而不是兩個）。指定確切版本（例如 `18.2.0`）。如果使用「最新」，則表示本文件上次更新時的最新穩定版本，並且應記錄特定版本（例如 `xyz-library@2.3.4`）。強烈建議鎖定版本，以避免 AI agent 發生意外的重大變更。 }

| 類別          | 技術                    | 版本／詳細資訊 | 說明／目的                | 理由 (選填)        |
| :------------ | :---------------------- | :------------- | :------------------------ | :----------------- |
| **語言**      | {例如，TypeScript}      | {例如，5.x}    | {後端/前端的主要語言}     | {為何選擇此語言？} |
|               | {例如，Python}          | {例如，3.11}   | {用於資料處理、機器學習}  | {...}              |
| **執行環境**  | {例如，Node.js}         | {例如，22.x}   | {伺服器端執行環境}        | {...}              |
| **框架**      | {例如，NestJS}          | {例如，10.x}   | {後端 API 框架}           | {為何選擇此框架？} |
|               | {例如，React}           | {例如，18.x}   | {前端 UI 函式庫}          | {...}              |
| **資料庫**    | {例如，PostgreSQL}      | {例如，15}     | {主要關聯式資料儲存}      | {...}              |
|               | {例如，Redis}           | {例如，7.x}    | {快取、工作階段儲存}      | {...}              |
| **雲端平台**  | {例如，AWS}             | {N/A}          | {主要雲端供應商}          | {...}              |
| **雲端服務**  | {例如，AWS Lambda}      | {N/A}          | {無伺服器運算}            | {...}              |
|               | {例如，AWS S3}          | {N/A}          | {用於資產/狀態的物件儲存} | {...}              |
|               | {例如，AWS EventBridge} | {N/A}          | {事件匯流排／排程任務}    | {...}              |
| **基礎設施**  | {例如，AWS CDK}         | {例如，最新版} | {基礎設施即程式碼工具}    | {...}              |
|               | {例如，Docker}          | {例如，最新版} | {容器化}                  | {...}              |
| **UI 函式庫** | {例如，Material UI}     | {例如，5.x}    | {React 組件函式庫}        | {...}              |
| **狀態管理**  | {例如，Redux Toolkit}   | {例如，最新版} | {前端狀態管理}            | {...}              |
| **測試**      | {例如，Jest}            | {例如，最新版} | {單元/整合測試框架}       | {...}              |
|               | {例如，Playwright}      | {例如，最新版} | {端對端測試框架}          | {...}              |
| **CI/CD**     | {例如，GitHub Actions}  | {N/A}          | {持續整合/持續部署}       | {...}              |
| **其他工具**  | {例如，LangChain.js}    | {例如，最新版} | {LLM 互動函式庫}          | {...}              |
|               | {例如，Cheerio}         | {例如，最新版} | {HTML 解析/抓取}          | {...}              |

## 基礎設施與部署概觀

- 雲端供應商：{例如，AWS、Azure、GCP、本地部署}
- 使用的核心服務：{列出主要受管理服務 - 例如，Lambda、S3、Kubernetes Engine、RDS、Kafka}
- 基礎設施即程式碼 (IaC)：{使用的工具 - 例如，AWS CDK、Terraform...} - 位置：{IaC 程式碼儲存庫/目錄連結}
- 部署策略：{例如，具有自動化升級的 CI/CD 管線、藍/綠部署、金絲雀部署} - 工具：{例如，Jenkins、GitHub Actions、GitLab CI}
- 環境：{列出環境 - 例如，開發、預備、生產}
- 環境升級：{描述步驟，例如，`dev` -> `staging` (手動核准／自動化測試通過) -> `production` (測試通過後自動化，可選用手動核准)}
- 回復策略：{例如，部署後健康檢查失敗時自動回復、透過 CI/CD 工作手動觸發、IaC 狀態回復。指定主要機制。}

## 錯誤處理策略

- **一般方法：** {例如，使用例外作為主要機制、為特定模組傳回錯誤碼/元組、明確定義的自訂錯誤類型階層。}
- **日誌記錄：**
  - 函式庫/方法：{例如，`console.log/error` (Node.js)、Python `logging` 模組與 `structlog`、專用日誌記錄函式庫如 `Pino` 或 `Serilog`。指定所選函式庫。}
  - 格式：{例如，JSON、帶有時間戳記和嚴重性的純文字。結構化日誌記錄建議使用 JSON。}
  - 層級：{例如，DEBUG、INFO、WARN、ERROR、CRITICAL。指定每個層級的標準用法。}
  - 情境：{必須包含哪些情境資訊？例如，關聯 ID、使用者 ID (若適用且安全)、服務名稱、操作名稱、關鍵參數 (已清理)。}
- **特定處理模式：**
  - 外部 API 呼叫：{定義重試機制 (例如，指數退避、最大重試次數 - 如果強制使用特定函式庫，如 `Polly` 或 `tenacity`，請指定)、斷路器模式用法 (例如，使用 `resilience4j` 或等效函式庫 - 指定是否使用及如何使用)、逾時設定 (連線和讀取逾時)。API 錯誤 (4xx、5xx) 如何轉換或傳播？}
  - 內部錯誤／業務邏輯例外：{如果適用，如何將內部錯誤轉換為使用者可見的錯誤 (例如，帶有唯一 ID 以供支援的通用錯誤訊息、特定錯誤碼)。是否有定義的業務例外類別？}
  - 交易管理：{在多步驟操作期間發生錯誤時確保資料一致性的方法，例如，資料庫交易 (如果非預設，請指定隔離層級)、用於分散式交易的 Saga 模式 (指定協調器/編排和補償邏輯)。}

## 編碼標準

{這些標準對 AI agent 和人類開發者產生的所有程式碼都是強制性的。除非在本節或連結的附錄中明確核准並記錄為例外情況，否則不允許偏離。}

- **主要執行環境：** {例如，Node.js 22.x、Lambda 的 Python 執行環境 - 請參考最終技術堆疊}
- **風格指南與 Linter：** {例如，ESLint 搭配 Airbnb 設定 + Prettier；Black、Flake8、MyPy；Go fmt、golint。指定所選工具並連結至設定檔 (例如，`.eslintrc.js`、`pyproject.toml`)。Linter 規則是強制性的，不得無故停用。}
- **命名慣例：**
  - 變數：`{例如，camelCase (JavaScript/TypeScript/Java)、snake_case (Python/Ruby)}`
  - 函式/方法：`{例如，camelCase (JavaScript/TypeScript/Java)、snake_case (Python/Ruby)}`
  - 類別/類型/介面：`{例如，PascalCase}`
  - 常數：`{例如，UPPER_SNAKE_CASE}`
  - 檔案：`{例如，kebab-case.ts (TypeScript)、snake_case.py (Python)、PascalCase.java (Java)。請針對每種語言具體說明。}`
  - 模組/套件：`{例如，camelCase 或 snake_case。請針對每種語言具體說明。}`
- **檔案結構：** 遵循「專案結構」部分和前端架構文件 (若適用) 中定義的佈局。
- **單元測試檔案組織：** {例如，`*.test.ts`／`*.spec.ts` 與原始檔案位於同一位置；`test_*.py` 位於平行的 `tests/` 目錄中，遵循語言慣例。}
- **非同步操作：** {例如，在 TypeScript/JavaScript/Python 中始終對基於 promise 的操作使用 `async`／`await`；在 Go 中使用 Goroutines/Channels，並具有清晰的錯誤傳播和完成模式；如果使用，則為 Java `CompletableFuture` 或 Project Reactor/RxJava。}
- **類型安全：** {例如，利用 TypeScript 嚴格模式 (啟用所有標記)；Python 類型提示 (由 MyPy 強制執行)；Go 靜態類型；Java 泛型並避免原始類型。所有新程式碼都必須嚴格類型化。}
  - _類型定義：_ {位置，例如 `src/common/types.ts`、共享套件或位於同一位置。關於使用 `any` 或等效類型的政策 (強烈不建議，需要理由)。}
- **註解與文件：**
  - 程式碼註解：{對程式碼註解的期望：對於複雜邏輯，解釋「為何」而非「做什麼」。避免多餘的註解。使用標準格式，如 JSDoc、TSDoc、Python docstrings (Google/NumPy 風格)、GoDoc、JavaDoc。}
  - README：{每個模組/套件/服務都應有一個 README，說明其目的、設定和用法 (如果不是微不足道的)。}
- **依賴管理：** {使用的工具 - 例如，npm/yarn、pip/poetry、Go 模組、Maven/Gradle。新增依賴項的政策 (例如，核准流程、檢查現有替代方案、安全漏洞掃描)。指定版本控制策略 (例如，偏好鎖定版本、對修補程式使用波浪號 `~`、對次要更新使用插入號 `^` - 請具體說明)。}

### 詳細的語言與框架慣例

{對於在「最終技術堆疊選擇」中選擇的每種主要語言和框架，**必須**遵守以下特定慣例。如果下面未列出所選技術，則表示遵守其標準、廣泛接受的最佳實務以及本文件中的一般準則。}

#### `{語言/框架 1 名稱，例如 TypeScript/Node.js}` 細節：

- **不可變性：** `{例如，「始終偏好不可變資料結構。對物件/陣列字面值使用 \`Readonly<T>\`、\`ReadonlyArray<T>\`、\`as const\`。避免直接修改作為 props 或 state 傳遞的物件/陣列。考慮使用像 Immer 這樣的函式庫來處理複雜的狀態更新。」}`
- **函數式 vs. 物件導向：** `{例如，「在實際可行的情况下，偏好使用函數式程式設計結構 (map、filter、reduce、純函數) 進行資料轉換和業務邏輯。對實體、具有明確狀態/職責的服務，或當框架慣例 (例如 NestJS) 要求時，使用類別。」}`
- **錯誤處理細節：** `{例如，「始終對 \`throw\` 使用 \`Error\` 物件或其擴充。確保 \`Promise\` 拒絕始終是 \`Error\` 物件。對領域特定錯誤使用繼承自基礎 \`AppError\` 的自訂錯誤類別。」}`
- **Null/Undefined 處理：** `{例如，「必須啟用嚴格的 null 檢查 (\`strictNullChecks\`)。避免使用 \`!\` 非 null 斷言運算子；偏好明確檢查、可選串聯 (\`?.\`) 或空值合併 (\`??\`)。為可選函式參數和傳回類型定義清晰的策略。」}`
- **模組系統：** `{例如，「僅使用 ESModules (\`import\`/\`export\`)。在新程式碼中避免使用 CommonJS (\`require\`/\`module.exports\`)。」}`
- **日誌記錄細節：** `{例如，「使用所選的結構化日誌記錄函式庫。日誌訊息必須包含關聯 ID。不要記錄敏感的 PII。使用適當的日誌層級。」}`
- **框架慣用語 (例如，針對 NestJS/Express)：** `{例如，「NestJS：始終使用裝飾器定義模組、控制器、服務、DTO。嚴格遵守定義的模組結構和依賴注入模式。Express：定義中介軟體模式、路由結構。」}`
- **主要函式庫使用慣例：** `{例如，「使用 Axios 時，建立單一設定的實例。對於日期/時間，使用 {date-fns/Luxon/Day.js} 並避免使用原生 \`Date\` 物件進行操作。」}`
- **應避免的程式碼產生反模式：** `{例如，「避免過度巢狀的條件邏輯 (最多 2-3 層)。避免使用單字母變數名稱 (除了像 \`i\`、\`j\`、\`k\` 這樣微不足道的迴圈計數器)。不要撰寫繞過框架安全功能的程式碼 (例如，ORM 查詢產生器)。」}`

#### `{語言/框架 2 名稱，例如 Python}` 細節：

- **不可變性：** `{例如，「對不可變序列使用元組。對於類別，考慮使用 \`@dataclass(frozen=True)\`。注意可變的預設參數。」}`
- **函數式 vs. 物件導向：** `{例如，「使用類別表示實體和服務。對無狀態操作使用函式。為了可讀性，列表推導式/產生器表達式優於 \`map/filter\`。」}`
- **錯誤處理細節：** `{例如，「始終引發繼承自基礎 \`AppException\` 的特定自訂例外。適當使用 \`try-except-else-finally\` 區塊。避免在沒有重新引發或特定處理的情況下使用寬泛的 \`except Exception:\` 子句。」}`
- **資源管理：** `{例如，「始終對檔案或資料庫連線等資源使用 \`with\` 陳述式，以確保它們被正確關閉。」}`
- **類型提示：** `{例如，「所有新函式和方法都必須有完整的類型提示。在 CI 中執行 MyPy。力求 \`disallow_untyped_defs = True\`。」}`
- **日誌記錄細節：** `{例如，「使用設定為結構化輸出的 \`logging\` 模組 (例如，搭配 \`python-json-logger\`)。包含關聯 ID。」}`
- **框架慣用語 (例如，針對 Django/Flask/FastAPI)：** `{例如，「Django：遵循胖模型、瘦視圖模式。使用 ORM 慣例。FastAPI：利用 Pydantic 處理請求/回應模型，並對服務使用依賴注入。」}`
- **主要函式庫使用慣例：** `{例如，「對於 HTTP 請求，使用具有明確逾時設定的 \`httpx\` 或 \`requests\`。對於資料操作，在適當情況下偏好使用 \`pandas\`，但要注意效能。」}`

#### `{視需要新增更多語言/框架部分...}`

- **{考慮受過訓練的 LLM 開發 Agent 可能會針對所選語言技術和平台隨機處理的其他事項，應在此處提醒它}**

## 整體測試策略

{本節概述專案的全面測試策略，所有 AI 產生和人工撰寫的程式碼都必須遵守。它補充了「最終技術堆疊選擇」中列出的測試工具。}

- **工具：** {重申技術堆疊中的主要測試框架和函式庫，例如 Jest、Playwright、PyTest、JUnit、Testcontainers。}
- **單元測試：**
  - **範圍：** {獨立測試個別函式、方法、類別或小型模組。專注於業務邏輯、演算法和轉換規則。}
  - **位置：** {例如，`*.test.ts`／`*.spec.ts` 與原始檔案位於同一位置；`test_*.py` 位於平行的 `tests/` 目錄中，遵循語言慣例。}
  - **模擬/樁模組：** {指定所選的模擬函式庫 (例如，Jest mocks、Python 中的 `unittest.mock`、Java 的 Mockito)。模擬所有外部依賴項 (網路呼叫、檔案系統、資料庫、時間)。}
  - **AI Agent 職責：** {AI Agent 必須為任何新增或修改的程式碼產生單元測試，涵蓋所有公用方法、重要邏輯路徑、邊緣案例和錯誤條件。}
- **整合測試：**
  - **範圍：** {測試應用程式邊界內多個組件或服務之間的互動。例如，API 端點到服務層到資料庫 (使用測試資料庫或記憶體內版本)。}
  - **位置：** {例如，`/tests/integration` 或 `/src/integration-test` (Java)。}
  - **環境：** {指定如何處理依賴項 (例如，用於資料庫/外部服務的 Testcontainers、記憶體內資料庫、專用測試環境)。}
  - **AI Agent 職責：** {AI Agent 可能會根據規格為關鍵服務互動或 API 端點產生整合測試。}
- **端對端 (E2E) 測試：**
  - **範圍：** {從使用者角度驗證完整的 使用者流程 或系統中的關鍵路徑 (例如，UI 互動、API 呼叫順序)。}
  - **工具：** {重申技術堆疊中的 E2E 測試工具 (例如，Playwright、Cypress、Selenium)。}
  - **AI Agent 職責：** {AI Agent 可能會根據 user stories 或 BDD 情境產生 E2E 測試樁模組或腳本。專注於關鍵的成功路徑和主要錯誤情境。}
- **測試覆蓋率：**
  - **目標：** {指定目標程式碼覆蓋率 (若有) (例如，單元測試的 80% 行/分支覆蓋率)。這是一個指導方針；測試品質優於原始覆蓋率數字。}
  - **衡量：** {用於覆蓋率報告的工具 (例如，Istanbul/nyc、Coverage.py、JaCoCo)。}
- **模擬/樁模組策略 (一般)：** {除了特定測試類型外，概述一般原則。例如，「在能提高測試清晰度和可維護性的情況下，偏好使用偽物件或測試替身，而不是廣泛的模擬。力求測試快速、可靠且隔離。」}
- **測試資料管理：** {如何建立、管理和隔離測試資料？例如，工廠、固定資料、設定/拆卸腳本、專用測試資料產生工具。}

## 安全最佳實務

{概述與程式碼庫相關的主要安全考量。這些是強制性的，AI agent 在開發過程中必須積極處理。}

- **輸入清理/驗證：** {為所有外部輸入 (API 請求、使用者提供的資料、檔案上傳) 指定函式庫/方法。例如，「對所有 API 輸入使用 class-validator 搭配 NestJS DTO；所有驗證規則都必須在 DTO 中定義。」對於其他語言，「對所有外部輸入使用 {validation_library}；定義結構描述和約束。」驗證必須在處理前於邊界進行。}
- **輸出編碼：** {指定在何處以及如何執行輸出編碼以防止 XSS 和其他注入攻擊。例如，「在 HTML 範本中呈現的所有動態資料都必須由範本引擎進行情境式自動逸出 (指定引擎並確認預設行為)。如果手動產生 HTML/XML/JSON，請使用核准的編碼函式庫，如 {encoder_library_name}。」}
- **機密管理：** {關於不同環境的儲存，請參考 `docs/environment-vars.md`。在程式碼中，僅透過指定的設定模組/服務存取機密。切勿寫死機密、將其包含在原始檔控制中或記錄它們。如果適用，請為本機開發使用特定工具 (例如，Doppler、未提交的 .env 檔案)。}
- **依賴項安全：** {檢查易受攻擊依賴項的政策。例如，「在 CI 中執行自動化漏洞掃描 (例如，`npm audit`、`pip-audit`、Snyk、Dependabot 警示)。根據嚴重性及時更新易受攻擊的依賴項。」新增依賴項的政策 (審查流程)。}
- **驗證/授權檢查：** {應在何處以及如何強制執行這些檢查？例如，「所有 API 端點 (明確公開的端點除外) 都必須使用中央驗證模組/中介軟體強制執行驗證。授權 (權限/角色檢查) 必須在受保護資源的服務層或進入點執行。」定義實作這些檢查的模式。}
- **最小權限原則 (實作)：** {例如，「資料庫連線使用者對於其存取的特定資料表/結構描述，只能擁有必要的權限 (SELECT、INSERT、UPDATE、DELETE)。雲端服務的 IAM 角色必須嚴格限定於所需的動作和資源。」}
- **API 安全 (一般)：** {例如，「強制使用 HTTPS。實作速率限制和節流 (指定工具/方法)。使用標準 HTTP 安全標頭 (CSP、HSTS、X-Frame-Options 等 - 指定哪些標頭及其設定)。遵循 REST/GraphQL 安全最佳實務。」}
- **錯誤處理與資訊洩漏：** {確保錯誤訊息不會向終端使用者洩漏敏感資訊 (堆疊追蹤、內部路徑、詳細的 SQL 錯誤)。在伺服器端記錄詳細錯誤，向用戶端提供通用訊息或錯誤 ID。}
- **定期安全稽核/測試：** {提及是否計劃進行，例如滲透測試、在 CI 中使用靜態/動態分析工具 (SAST/DAST)。}
- **{其他相關實務，例如：檔案上傳安全、工作階段管理安全、除了 HTTPS 之外的靜態和傳輸中資料加密 (如果存在特定要求)。}**

## 關鍵參考文件

{ 若有 }

## 變更日誌

| 變更 | 日期 | 版本 | 說明 | 作者 |
| ---- | ---- | ---- | ---- | ---- |

--- 以下，提示設計架構師 (如果專案有 UI) 產生前端架構 ----

==================== 結束：architecture-tmpl ====================

==================== 開始：doc-sharding-tmpl ====================

# 文件分片計畫範本

此計畫指導 agent 如何在其 Librarian 階段將大型來源文件分解為更小、更細微的檔案。agent 將參考此計畫來識別來源文件、要擷取的特定部分以及分片內容的目標檔案名稱。

---

## 1. 來源文件：PRD (專案需求文件)

- **給 Agent 的筆記：** 與使用者確認 PRD 的確切檔案名稱 (例如，`PRD.md`、`ProjectRequirements.md`、`prdx.y.z.md`)。

### 1.1. Epic 細化

- **指示：** 對於 PRD 中識別的每個 Epic：
- **要複製的來源區段：** Epic 的完整文字，包括其主要說明、目標以及該 Epic 下所有相關的 user stories 或詳細需求。確保擷取從類似「**Epic X：**」的標題開始，到下一個此類標題或「Epic 概觀」區段結尾的內容。
- **目標檔案模式：** `docs/epic-<id>.md`
  - _Agent 筆記：`<id>` 應對應 Epic 編號。_

---

## 2. 來源文件：主要架構文件

- **給 Agent 的筆記：** 與使用者確認確切的檔案名稱 (例如，`architecture.md`、`SystemArchitecture.md`)。

### 2.1. 核心架構細化

- **要複製的來源區段：** 詳細說明「API 參考」、「API 端點」或「服務介面」的區段。
- **目標檔案：** `docs/api-reference.md`

- **要複製的來源區段：** 詳細說明「資料模型」、「資料庫結構描述」、「實體定義」的區段。
- **目標檔案：** `docs/data-models.md`

- **要複製的來源區段：** 標題為「環境變數文件」、「設定」、「部署參數」的區段，或者如果在「基礎設施與部署概觀」中找不到專用區段，則為相關子區段。
- **目標檔案：** `docs/environment-vars.md`

  - _Agent 筆記：如果可用，優先考慮專用的「環境變數」區段或連結的「environment-vars.md」來源。如果沒有，則從「基礎設施與部署概觀」中擷取相關的設定詳細資訊。此分片用於特定的變數定義和用法。_

- **要複製的來源區段：** 詳細說明「專案結構」的區段。
- **目標檔案：** `docs/project-structure.md`

  - _Agent 筆記：如果專案涉及多個儲存庫 (非 monorepo)，請確保此檔案清楚描述每個相關儲存庫的結構，或視需要連結至子檔案。_

- **要複製的來源區段：** 詳細說明「技術堆疊」、「關鍵技術」、「函式庫與框架」或「最終技術堆疊選擇」的區段。
- **目標檔案：** `docs/tech-stack.md`

- **要複製的來源區段：** 詳細說明「編碼標準」、「開發準則」、「最佳實務」、「測試策略」、「測試決策」、「QA 流程」、「整體測試策略」、「錯誤處理策略」和「安全最佳實務」的區段。
- **目標檔案：** `docs/operational-guidelines.md`

  - _Agent 筆記：此檔案整合了幾個關鍵的營運方面。確保來自每個來源區段（「編碼標準」、「測試策略」、「錯誤處理策略」、「安全最佳實務」）的內容在此文件中的 H3 (###) 或 H4 (####) 標題下清楚地劃分。_

- **要複製的來源區段：** 標題為「組件視圖」的區段 (包括「採用的架構／設計模式」等子區段)。
- **目標檔案：** `docs/component-view.md`

- **要複製的來源區段：** 標題為「核心工作流程／循序圖」的區段 (包括所有子圖)。
- **目標檔案：** `docs/sequence-diagrams.md`

- **要複製的來源區段：** 標題為「基礎設施與部署概觀」的區段。
- **目標檔案：** `docs/infra-deployment.md`

  - _Agent 筆記：這是更廣泛的概觀，與特定的 `docs/environment-vars.md` 不同。_

- **要複製的來源區段：** 標題為「關鍵參考文件」的區段。
- **目標檔案：** `docs/key-references.md`

---

## 3. 來源文件：前端特定文件

- **給 Agent 的筆記：** 與使用者確認檔案名稱 (例如，`front-end-architecture.md`、`front-end-spec.md`、`ui-guidelines.md`)。可能存在多個前端文件。

### 3.1. 前端細化

- **要複製的來源區段：** 詳細說明「前端專案結構」或「詳細前端目錄結構」的區段。
- **目標檔案：** `docs/front-end-project-structure.md`

- **要複製的來源區段：** 詳細說明「UI 風格指南」、「品牌指南」、「視覺設計規格」或「樣式設定方法」的區段。
- **目標檔案：** `docs/front-end-style-guide.md`

  - _Agent 筆記：此區段可能是子區段或參考其他文件 (例如，`ui-ux-spec.txt`)。擷取前端架構文件本身定義的核心樣式設定理念和方法。_

- **要複製的來源區段：** 詳細說明「組件庫」、「可重複使用 UI 組件指南」、「原子設計元素」或「組件分解與實作細節」的區段。
- **目標檔案：** `docs/front-end-component-guide.md`

- **要複製的來源區段：** 詳細說明「前端編碼標準」的區段 (特別針對 UI 開發，例如 JavaScript/TypeScript 風格、CSS 命名慣例、前端的無障礙最佳實務)。
- **目標檔案：** `docs/front-end-coding-standards.md`

  - _Agent 筆記：可能不存在專用的頂層區段。如果找不到，此分片可能為空，或需要與主要架構的編碼標準進行交叉參考。擷取任何提及的前端特定編碼慣例。_

- **要複製的來源區段：** 標題為「狀態管理深入探討」的區段。
- **目標檔案：** `docs/front-end-state-management.md`

- **要複製的來源區段：** 標題為「API 互動層」的區段。
- **目標檔案：** `docs/front-end-api-interaction.md`

- **要複製的來源區段：** 標題為「路由策略」的區段。
- **目標檔案：** `docs/front-end-routing-strategy.md`

- **要複製的來源區段：** 標題為「前端測試策略」的區段。
- **目標檔案：** `docs/front-end-testing-strategy.md`

---

關鍵：**索引管理：** 建立檔案後，視需要更新 `docs/index.md` 以參考並描述每個文件 - 不要提及細化或其分片來源，只需說明文件目的 - 因為索引也可能包含其他文件參考。
